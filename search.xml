<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MongoDB基础</title>
      <link href="/2019/06/23/mongodb/"/>
      <url>/2019/06/23/mongodb/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>在MongoDB中，数据库和集合都不需要手动创建，当我们创建文档时，如果文档所在的集合或数据库不存在，会自动创建数据库和集合</strong></p><ul><li>数据库（database）</li><li>集合（collection）</li><li>文档（document）</li></ul><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show dbs OR show databases# 显示当前所有数据库</span><br><span class="line">use &lt;database&gt;# 进入指定数据库</span><br><span class="line">db # 显示当前所处数据库</span><br><span class="line">show collections# 显示数据库中的集合</span><br></pre></td></tr></table></figure><h2 id="数据库CRUD的查询"><a href="#数据库CRUD的查询" class="headerlink" title="数据库CRUD的查询"></a>数据库CRUD的查询</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$or       逻辑或</span><br><span class="line">$and     逻辑与</span><br><span class="line">$not      逻辑非</span><br><span class="line">$nor      逻辑or的取反</span><br><span class="line">$exists   存在逻辑</span><br><span class="line">$type     查询键的数据类型</span><br><span class="line">$push操作符添加指定的值到数组中</span><br><span class="line">$ne一个值不在数组里时就把它加进去，避免重复数据 </span><br><span class="line">$<span class="keyword">set</span> 可以用来修改文档中指定属性</span><br><span class="line">$unset 可以删除文档中的制定属性</span><br><span class="line">$addToSet往数组里面加入数据，如果数组里已经存在，则不会加入</span><br><span class="line">$pop删除数组元素，只能从头部或尾部删除一个元素 </span><br><span class="line">$pull删除数组元素，将所有匹配的元素删除</span><br><span class="line">$gt查找大于</span><br><span class="line">$gte查找大于等于</span><br><span class="line">$lt查找小于</span><br><span class="line">$inc自增</span><br><span class="line">&#123;$gt:value，$lt:value&#125;查找区间</span><br></pre></td></tr></table></figure><h2 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;collection&gt;.insert(doc)# 在&lt;collection&gt;中插入一个文档</span><br><span class="line">db.collection.insertOne(doc)# 插入一个文档</span><br><span class="line">db.collection.insertMany(doc)# 插入多个文档</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;collection&gt;.find(doc)# 查询当前集合中所有文档,返回一个数组</span><br><span class="line">db.&lt;collection&gt;.find(&#123;'doc.doc':'值'&#125;)# 查询当前集合中文档中的文档值</span><br><span class="line">db.&lt;collection&gt;.findOne(doc)# 查询一个，返回文档</span><br><span class="line">db.&lt;collection&gt;.find(doc).count()# 查询符合条件的是几个文档</span><br><span class="line">db.&lt;collection&gt;.find(doc).limit(10)# 查找前十的数据</span><br><span class="line">db.&lt;collection&gt;.find(doc).skip(10).limit(10)# 查找11条到20条的数据</span><br><span class="line">db.&lt;collection&gt;.find($or:[条件，条件])# 查找11条到20条的数据</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update() 默认情况使用新对象替换旧对象/默认只会修改一个</span><br><span class="line">db.&lt;collection&gt;.update(&#123;查询条件&#125;，&#123;新对象&#125;)# 替换一个文档</span><br><span class="line">db.&lt;collection&gt;.update(&#123;查询条件&#125;，&#123;$set:&#123;属性&#125;&#125;)# 修改一个文档</span><br><span class="line">db.&lt;collection&gt;.update(&#123;查询条件&#125;，&#123;$unset:&#123;属性&#125;&#125;)# 删除一个文档</span><br><span class="line">db.&lt;collection&gt;.update(&#123;查询条件&#125;，&#123;$push/$addToSet:&#123;属性&#125;&#125;)# 像数组中添加一个新元素</span><br><span class="line">db.&lt;collection&gt;.updateMany() OR db.&lt;collection&gt;.update(&#123;multi:true&#125;)# 修改多个</span><br><span class="line">db.&lt;collection&gt;.repleceOne()# 替换多个</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">remove() 默认删除多个/必须传参</span><br><span class="line">remove(&#123;&#125;) 清空集合</span><br><span class="line">db.&lt;collection&gt;.remove(属性)# 删除符合条件所有文档</span><br><span class="line">db.&lt;collection&gt;.remove(属性,true)# 删除一个文档</span><br><span class="line">db.&lt;collection&gt;.drop()# 删除集合</span><br><span class="line">db.dropDatabase()# 删库跑路</span><br></pre></td></tr></table></figure><h2 id="插入多数据"><a href="#插入多数据" class="headerlink" title="插入多数据"></a>插入多数据</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1; i&lt;=100; i++)&#123;db.&lt;collection&gt;.insert(doc:i)&#125;# 循环插入100条数据</span><br><span class="line">-------------------------------</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;arr.push(&#123;<span class="attr">doc</span>:i&#125;);&#125;</span><br><span class="line">db.&lt;collection&gt;.insert(arr)# 快速插入100条数据</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mock基础</title>
      <link href="/2019/06/02/mock/"/>
      <url>/2019/06/02/mock/</url>
      
        <content type="html"><![CDATA[<h2 id="如何解决依赖产生的痛点"><a href="#如何解决依赖产生的痛点" class="headerlink" title="如何解决依赖产生的痛点"></a>如何解决依赖产生的痛点</h2><p>1、使用代理工具实现MOCK服务器<br>2、在测试中代码mock，写个mock服务<br>3、真实写个临时接口返回</p><h2 id="mock介绍"><a href="#mock介绍" class="headerlink" title="mock介绍"></a>mock介绍</h2><ul><li>unittest.mock是一个用于在Python中进行测试的库。它允许你使用模拟对象替换受测试系统的部分，检查调用并对如何使用它们进行断言。</li><li>unittest.mock提供了一个核心Mock类，还有MagicMock.<ul><li>执行操作后，您可以断言使用哪种方法/属性以及调用他们的参数。</li><li>您还可以制定返回参数并以正常方式设置所需属性</li><li>mock的patch()装饰器，用于处理测试范围内的修补模块和类级属性</li></ul></li></ul><h2 id="希望得到返回数据"><a href="#希望得到返回数据" class="headerlink" title="希望得到返回数据"></a>希望得到返回数据</h2><ul><li><p>设置返回值和属性</p></li><li><p>mock object对象的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mock = Mock()</span><br><span class="line">mock.return_value = <span class="number">3</span></span><br><span class="line">mock()</span><br></pre></td></tr></table></figure></li><li><p>methods具体方法返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mock.something.return_value = <span class="number">3</span></span><br><span class="line">mock.something()</span><br></pre></td></tr></table></figure></li><li><p>attribute setting 属性的设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mock.x = <span class="number">5</span></span><br><span class="line">mock.x</span><br></pre></td></tr></table></figure></li><li><p>通过构造方法-传参的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mock = Mock(return_value = <span class="number">3</span>)</span><br><span class="line">mock()</span><br></pre></td></tr></table></figure></li><li><p>多次不同返回值及顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mock.side_effect = (<span class="number">200</span>,<span class="number">404</span>,<span class="number">302</span>,<span class="number">500</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="希望跟踪多个方法是否被调用和断言"><a href="#希望跟踪多个方法是否被调用和断言" class="headerlink" title="希望跟踪多个方法是否被调用和断言"></a>希望跟踪多个方法是否被调用和断言</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跟踪是否被调用</span></span><br><span class="line">mock_calls</span><br><span class="line"><span class="comment"># 断言是否调用的这个参数</span></span><br><span class="line">assert_called_with()</span><br><span class="line"><span class="comment"># 断言是否只调用一次</span></span><br><span class="line">assert_called_once_with()</span><br></pre></td></tr></table></figure><h2 id="对已有的类的实例使用patch临时改变返回值"><a href="#对已有的类的实例使用patch临时改变返回值" class="headerlink" title="对已有的类的实例使用patch临时改变返回值"></a>对已有的类的实例使用patch临时改变返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入需要测试的类，mock库，patch</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> testClass</span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># some_function方法是调用要测试的实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span><span class="params">()</span>:</span></span><br><span class="line">    ins = testClass.method()  <span class="comment"># 调用测试类中的模块   </span></span><br><span class="line">    <span class="keyword">return</span> ins.method()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用with patch方法将要mock的方法写出来，加了返回值和方法返回值，是拦截了命名空间先调用了mock</span></span><br><span class="line"><span class="keyword">with</span> patch(<span class="string">'test.testClass.method'</span>) <span class="keyword">as</span> mock:</span><br><span class="line">    ins = mock.return_value</span><br><span class="line">    ins.method.return_value = <span class="string">'result'</span></span><br><span class="line">    result = some_function()</span><br><span class="line">    <span class="keyword">assert</span> result == <span class="string">'result'</span></span><br></pre></td></tr></table></figure><h2 id="mock扩展应用-性能测试解决方案之一"><a href="#mock扩展应用-性能测试解决方案之一" class="headerlink" title="mock扩展应用-性能测试解决方案之一"></a>mock扩展应用-性能测试解决方案之一</h2><ul><li>进行自服务器的压力测试方案</li><li>直接使用线上的后端服务进行压测<ul><li>优点：近线上状态，代价极小</li><li>缺点：线上子服务的稳定性，数据统计，引入脏数据等</li></ul></li><li>部署完整的后端测试环境、<ul><li>优点：与线上隔离；测试结果基本与线上环境一致，测试结果相对准确</li><li>缺点：部署成本极高，要保证子服务性能会造成的资源浪费</li></ul></li><li>部署部分子服务<ul><li>优点：与线上隔离；部署成本相对较小</li><li>缺点：测试结果有出处，后端性能可能是瓶颈</li></ul></li><li>使用测试平台mock后端接口数据<ul><li>优点：与线上隔离；</li><li>缺点：mock平台一般性能较弱，测试结果有出入；mock平台的逻辑规则会有一定学习成本（可以通过django写的mock服务）</li></ul></li><li>使用nginx cache mock子服务返回内容：<ul><li>优点：与线上隔离子服务返回内容与线上一致；可保证后端性能不是瓶颈</li><li>缺点：必须使用固定的一组请求（请求数量在几万的量级没有问题）</li></ul></li></ul><h2 id="爬坑"><a href="#爬坑" class="headerlink" title="爬坑"></a>爬坑</h2><ul><li>@patch 的路径一定要完整</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker下使用MySQL</title>
      <link href="/2019/05/23/docker%20%E4%B8%8B%E4%BD%BF%E7%94%A8mysql/"/>
      <url>/2019/05/23/docker%20%E4%B8%8B%E4%BD%BF%E7%94%A8mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="docker中搜索可用镜像"><a href="#docker中搜索可用镜像" class="headerlink" title="docker中搜索可用镜像"></a>docker中搜索可用镜像</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker search mysql</span><br></pre></td></tr></table></figure><h2 id="获取mysql镜像"><a href="#获取mysql镜像" class="headerlink" title="获取mysql镜像"></a>获取mysql镜像</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker pull mysql</span><br></pre></td></tr></table></figure><h2 id="运行docker下mysql"><a href="#运行docker下mysql" class="headerlink" title="运行docker下mysql"></a>运行docker下mysql</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 --restart=always  mysql</span><br><span class="line"><span class="meta">$</span> docker run --name mysql_dev -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306  -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci # 创建容器的时候就指定utf8编码</span><br><span class="line"><span class="meta">#</span> 以上参数定义</span><br><span class="line">--name mysql  将容器命名为mysql，后面可以用这个name进行容器的启动暂停等操作</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 设置MySQL密码为123456</span><br><span class="line">-d 此容器在后台运行,并且返回容器的ID</span><br><span class="line">-i 以交互模式运行容器</span><br><span class="line">-p 进行端口映射，格式为主机(宿主)端口:容器端口</span><br><span class="line">--restart=always 当docker重启时，该容器自动重启</span><br></pre></td></tr></table></figure><h2 id="进入MySQL容器"><a href="#进入MySQL容器" class="headerlink" title="进入MySQL容器"></a>进入MySQL容器</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker exec -ti mysql bash</span><br></pre></td></tr></table></figure><h2 id="MySQL中文乱码"><a href="#MySQL中文乱码" class="headerlink" title="MySQL中文乱码"></a>MySQL中文乱码</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show variables like &apos;character_set%&apos;; # 查看mysql字符集</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 修改/etc/mysql、my.cnf</span><br><span class="line"><span class="meta">#</span>在[]便签下添加如下参数配置</span><br><span class="line">[mysqld]</span><br><span class="line">default-character-set = utf8</span><br><span class="line">character_set_server = utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set = utf8</span><br><span class="line">[mysql.server]</span><br><span class="line">default-character-set = utf8</span><br><span class="line">[mysqld_safe]</span><br><span class="line">default-character-set = utf8</span><br><span class="line">[client]</span><br><span class="line">default-character-set = utf8</span><br></pre></td></tr></table></figure><p>linux用于磁盘管理 LVM</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WSL安装mysql</title>
      <link href="/2019/05/20/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/05/20/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="WSL-UBUNTU"><a href="#WSL-UBUNTU" class="headerlink" title="WSL.UBUNTU"></a>WSL.UBUNTU</h1><h2 id="WSL安装mysql"><a href="#WSL安装mysql" class="headerlink" title="WSL安装mysql"></a>WSL安装mysql</h2><p>1、更新apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 备份源文件</span><br><span class="line"><span class="meta">$</span> sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="meta">#</span> 编辑源文件列表</span><br><span class="line"><span class="meta">$</span> sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span> 使用[国内镜像源](https://blog.csdn.net/xiangxianghehe/article/details/80112149)替换原声源</span><br><span class="line"><span class="meta">#</span> 更新apt</span><br><span class="line"><span class="meta">$</span> sudo apt update</span><br></pre></td></tr></table></figure><p>2、安装MYSQL服务器版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt install mysql-server</span><br></pre></td></tr></table></figure><p>3、启动MYSQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> mysql是rpm安装的</span><br><span class="line"><span class="meta">#</span>启动mysql</span><br><span class="line"><span class="meta">$</span> service mysqld start</span><br><span class="line"><span class="meta">#</span>关闭mysql</span><br><span class="line"><span class="meta">$</span> service mysqld stop</span><br><span class="line"><span class="meta">#</span> 二进制和源码安装的</span><br><span class="line"><span class="meta">#</span>启动mysql</span><br><span class="line"><span class="meta">$</span> /etc/init.d/mysqld start</span><br><span class="line"><span class="meta">#</span>关闭mysql</span><br><span class="line"><span class="meta">$</span> /etc/init.d/mysqld stop | /usr/bin/mysqladmin -u root -p shutdown</span><br><span class="line"><span class="meta">#</span>重启mysql    </span><br><span class="line"><span class="meta">$</span> /etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure><p>4、MYSQL可能出现的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)</span><br></pre></td></tr></table></figure><blockquote><p>方案1</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps -A|grep mysql</span><br><span class="line"><span class="meta">#</span> 显示类似：</span><br><span class="line"><span class="meta">$</span> 1829 ?        00:00:00 mysqld_safe</span><br><span class="line"><span class="meta">$</span> 1876 ?        00:00:31 mysqld</span><br><span class="line"><span class="meta">$</span> kill -9 1829</span><br><span class="line"><span class="meta">$</span> kill -9 1876</span><br><span class="line"><span class="meta">$</span> /etc/init.d/mysql restart</span><br><span class="line"><span class="meta">$</span> mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><p>方案2</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 先查看mysql是否已经启动</span><br><span class="line"><span class="meta">$</span> /etc/rc.d/init.d/mysqld status </span><br><span class="line"><span class="meta">#</span> 另外看看是不是权限问题.</span><br><span class="line"><span class="meta">$</span> chown -R mysql:mysql /var/lib/mysql</span><br><span class="line"><span class="meta">$</span> /etc/init.d/mysqld start</span><br><span class="line"><span class="meta">$</span> 启动 MySQL： [ 确定 ]</span><br><span class="line"><span class="meta">$</span> mysqladmin -uroot password '123456'</span><br><span class="line"><span class="meta">$</span> mysql -uroot -p</span><br></pre></td></tr></table></figure><blockquote><p>方案3</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_connections=1000 他说太多了，然后改成500也说多，无奈删之问题解决了。</span><br></pre></td></tr></table></figure><blockquote><p>方案4</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /var/lib/mysql </span><br><span class="line"><span class="meta">#</span> 所有文件权限 改成mysql.mysql</span><br></pre></td></tr></table></figure><blockquote><p>方案5<br>     摘要：解决不能通过mysql .sock连接MySQL问题 这个问题主要提示是，不能通过 ‘/tmp/mysql .sock’连到服务器，而php标准配置正是用过’/tmp/mysql .sock’，但是一些mysql 安装方法 将 mysql .sock放在/var/lib/mysql .sock或者其他的什么地方，你可以通过修改/etc/my.cnf文件来修正它，打开文件，可以看到如下的东东：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysql d] </span><br><span class="line">socket=/var/lib/mysql .sock </span><br><span class="line"><span class="meta">#</span> 改一下就好了，但也会引起其他的问题，如mysql 程序连不上了，再加一点： </span><br><span class="line">[mysql] </span><br><span class="line">socket=/tmp/mysql .sock </span><br><span class="line">或者还可以通过修改php.ini中的配置来使php用其他的mysql .sock来连，这个大家自己去找找</span><br><span class="line">或者用这样的方法:ln -s /var/lib/mysql /mysql .sock /tmp/mysql .sock</span><br></pre></td></tr></table></figure><p>5、在windows下连接WSL中的MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 当连接提示报错是因为MySQL把 Windows 下的程序的连接视为远程 MySQL 请求，若你使用的 MySQL 用户没有远程权限，则会出错</span><br><span class="line"><span class="meta">#</span> 解决方法，WSL进入mysql中 </span><br><span class="line"><span class="meta">$</span> use mysql;</span><br><span class="line"><span class="meta">$</span> update user set host = '%' where user = 'root';</span><br><span class="line"><span class="meta">$</span> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '' WITH GRANT OPTION;</span><br><span class="line"><span class="meta">$</span> FLUSH PRIVILEGES;</span><br><span class="line"><span class="meta">#</span> 现在就可以使用 root 账户连接，无密码</span><br></pre></td></tr></table></figure><h2 id="WSL安装java"><a href="#WSL安装java" class="headerlink" title="WSL安装java"></a>WSL安装java</h2><p>1、从官网下载tar.gz结尾的java压缩包，放到/opt/目录下解压<br>2、输入命令vim /etc/profile，打开环境变量配置文件在文件底部输入以下信息，并保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/home/java/jdk1.8.0_131</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><p>3、建立连接/usr/bin/java的超链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/java/jdk1.8.0_131/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="/2019/04/23/dockerBasis/"/>
      <url>/2019/04/23/dockerBasis/</url>
      
        <content type="html"><![CDATA[<h1 id="docker基础"><a href="#docker基础" class="headerlink" title="docker基础"></a>docker基础</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ul><li><p><strong>启动容器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run image [command] [ARG]</span><br></pre></td></tr></table></figure></li><li><p><strong>启动交互式容器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -i -t IMAGE /bin/bash </span><br><span class="line"><span class="meta">$</span> docker run --name mysqltest -i -t centos:7 /bin/bash</span><br></pre></td></tr></table></figure></li><li><p><strong>查看容器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker ps [-a] [-l] # -a 查看所有容器信息  -l 列出最新容器</span><br><span class="line"><span class="meta">$</span> docker inspect[] # 查看容器信息</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bean Shell基础</title>
      <link href="/2018/12/11/Bean%20Shell/"/>
      <url>/2018/12/11/Bean%20Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Bean-Shell"><a href="#什么是Bean-Shell" class="headerlink" title="什么是Bean Shell"></a>什么是Bean Shell</h2><ul><li>BeanShell是一种完全符合Java语法规范的脚本语言，并且有拥有自己的一些语法和方法。</li><li>BeanShell是一种松散类型的脚本语言（这点和JS）类似。</li><li>BeanShell是用Java写成的，一个小型的、免费的、可下载的、嵌入式的Java源代码解释器，具有对象脚本语言特性，非常精简的解释器。</li><li>BeanShell执行标准的Java语句和表达式，另外包括一些脚本命令和语法。</li></ul><h2 id="Jmeter有哪些Bean-Shell"><a href="#Jmeter有哪些Bean-Shell" class="headerlink" title="Jmeter有哪些Bean Shell"></a>Jmeter有哪些Bean Shell</h2><ul><li>定时器：　　BeanShell Timer</li><li>前置处理器：BeanShell PreProcessor</li><li>采样器：　　BeanShell Sampler</li><li>后置处理器：BeanShell PostProcessor</li><li>断言：　　　BeanShell断言</li><li>监听器：　　BeanShell Listener</li></ul><h2 id="BeanShell的用法"><a href="#BeanShell的用法" class="headerlink" title="BeanShell的用法"></a>BeanShell的用法</h2><h2 id="BeanShell常用内置变量"><a href="#BeanShell常用内置变量" class="headerlink" title="BeanShell常用内置变量"></a>BeanShell常用内置变量</h2><p>JMeter在它的BeanShell中内置了变量，用户可以通过这些变量与JMeter进行交互，其中主要的变量及其使用方法如下:</p><ul><li><p>log：写入信息到jmeber.log文件，使用方法：log.info(“This is log info!”);</p></li><li><p>ctx：该变量引用了当前线程的上下文，使用方法可参 org.apache.jmeter.threads.JMeterContext。</p></li><li><p>vars - (JMeterVariables)：操作jmeter变量，这个变量实际引用了JMeter线程中的局部变量容器（本质上是Map），它是测试用例与BeanShell交互的桥梁，常用方法：<br>　　 　     a) vars.get(String key)：从jmeter中获得变量值<br>　　  　b) vars.put(String key，String value)：数据存到jmeter变量中</p></li><li><p>props - (JMeterProperties - class java.util.Properties)：操作jmeter属性，该变量引用了JMeter的配置信息，可以获取Jmeter的属性，它的使用方法与vars类似，但是只能put进去String类型的值，而不能是一个对象。对应于java.util.Properties。<br>　　　　a) props.get(“START.HMS”);　注：START.HMS为属性名，在文件jmeter.properties中定义<br>　　　　b) props.put(“PROP1”,”1234”); </p></li><li><p>prev - (SampleResult)：获取前面的sample返回的信息，常用方法：<br>　　　　a) getResponseDataAsString()：获取响应信息<br>　　　　b) getResponseCode() ：获取响应code</p></li><li><p>sampler - (Sampler)：gives access to the current sampler</p></li></ul><h2 id="beanshell-usage"><a href="#beanshell-usage" class="headerlink" title="beanshell-usage"></a>beanshell-usage</h2><ol><li><p>添加http请求，数据参数化</p></li><li><p>添加beanshellpreprcessor</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vars.put("user","admin123");//定义请求数据中的参数:用户名</span><br><span class="line">vars.put("pass","admin123");//定义请求数据中的参数：密码</span><br><span class="line">save=vars.put("save","false");//定义请求数据中的参数：是否保存登录信息</span><br></pre></td></tr></table></figure></li><li><p>添加beanshell断言</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String username=vars.get("user");//获取参数中的用户名信息</span><br><span class="line">log.info("用户名:"+username);//打印用户名</span><br></pre></td></tr></table></figure></li><li><p>添加beanshellpostprocessor</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp_text=prev.getResponseDataAsString();//获取请求的响应结果</span><br><span class="line">log.info(resp_text);//打印响应结果</span><br><span class="line">log.info(resp_code);//打印响应代码</span><br><span class="line">resp_mes=prev.getResponseMessage();//获取响应结果的消息</span><br><span class="line">log.info(resp_mes);//打印响应结果的消息</span><br><span class="line">pro=props.get("START.HMS");//获取START.HMS的属性信息</span><br><span class="line">log.info(pro);//打印START.HMS的属性信息</span><br></pre></td></tr></table></figure></li><li><p>自定义函数：添加beanshell sample，编写脚本</p></li><li><p>添加debug Sample,用于调试脚本</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nmon监控linux系统资源</title>
      <link href="/2018/10/29/nmon%E7%9B%91%E6%8E%A7/"/>
      <url>/2018/10/29/nmon%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="nmon简介"><a href="#nmon简介" class="headerlink" title="nmon简介"></a>nmon简介</h2><p>nmon是一个分析aix和linux性能的免费工具（其主要是ibm为自己的aix操作系统开发的，但是也可以应用在linux操作系统上）<br>nmon_analyser：是nmon的一个工具可以把nmon生成的报告转化成excel报表的形式供我们查看。两者的结合可以把各个硬件的监控信息生成形象化的分析报表图<br>下载地址：<a href="http://nmon.sourceforge.net/pmwiki.php?n=Site.Download" target="_blank" rel="noopener">http://nmon.sourceforge.net/pmwiki.php?n=Site.Download</a></p><h2 id="安装使用方法"><a href="#安装使用方法" class="headerlink" title="安装使用方法"></a>安装使用方法</h2><p>1.用root用户登录Linux操作系统，建立目录：#mkdir /opt/nmon<br>2.切换路径：cd /opt/nmon<br>3.用命令rz将下载的nmon工具上传至Linux服务器 目录/opt/nmon下<br>4.修改tar包权限：#chmod +x nmon_linux_14i_newer_Linux_versions.tar.gz<br>5.解压文件：#tar -xzvf nmon_linux_14i_newer_Linux_versions.tar.gz<br>5.执行授权命令：#chmod +x nmon_linux_x86<br>6.更改名字 : # mv nmon_linux_x86 nmon<br>7.运行nmon命令: # ./nmon<br>8.敲c:CPU相关资源信息<br>9.敲m:memory相关资源信息<br>10.敲d:disk磁盘相关信息<br>11.敲n:network相关信息<br>12.创建一个存放结果的文件夹：mkdir /opt/nmon/log<br>13.监控系统资源：./nmon -f -N -m /opt/nmon/log/ -s 10 -c 60,每10秒采集一次数据，采集60次<br>14.使用命令sz，将Linux系统中的文件下载到Windows本地<br>15.解压nmon_analyser_v51_2.zip，打开nmon analyser v51_2.xlsm，启用宏，方可使用<br>16.点击Analyser nmon data,选择已经下载好的结果文件，自动生成报告。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能测试基础</title>
      <link href="/2018/10/11/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/10/11/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="性能测试分类"><a href="#性能测试分类" class="headerlink" title="性能测试分类"></a>性能测试分类</h2><ul><li>负载测试（Load testing）<ul><li>负载测试是不断增加系统的负载，直到负载达到阈值——评估系统在预期工作负载下的性能的测试。</li></ul></li><li>压力测试（Stress Testing）<ul><li>压力测试是指当硬件资源如cpu、内存、磁盘空间等不充足时对软件稳定性的检查。</li><li>压力测试属于负面测试（Negative testing），使大量并发用户/进程加载软件以使系统硬件资源不能应付。这个测试也被称为是疲劳测试（Fatigue testing），通过超出其能力的测试来捕获应用程序的稳定性。</li></ul></li><li>尖峰测试（Spike testing）<ul><li>尖峰测试是在目标系统经受短时间内反复增加工作负载，以至超出预期生产操作的负载量时，分析系统的行为，验证其性能特征。它还包括检查应用程序是否可以从突然增加的超预期负荷中恢复出来的测试。</li></ul></li><li>可扩展性测试（Scalability Testing）<ul><li>可扩展性测试是一种非功能的测试，它测试软件应用程序以确定所有非功能能力的扩展能力，如用户负载支持、事务数量、数据量等。</li></ul></li><li>容量测试（Volume testing）<ul><li>容量测试是一种非功能的测试，它通过向应用程序中添加大量的数据来实现。可以通过向数据库插入大量的数据或让应用程序处理一个大型文件来进行测试应用程序。</li><li>通过容量测试，可以识别应用程序中具有大数据时的瓶颈，检查应用程序的效率，进而得到不同数据量级下应用程序的性能。</li></ul></li><li>持久测试（Endurance testing）<ul><li>持久测试也被称为是浸泡测试（Soak Testing），它也是一种非功能的测试。</li><li>持久测试是指在相当长的时间内使用预期的负载量对系统进行测试，以检查系统的各种行为，如内存泄露、系统错误、随机行为等。</li></ul></li></ul><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ul><li>响应时间 RT Response Time 首屏时间–客户端请求服务器 发首页请求的响应时间</li><li>吞吐量：BPS RPS</li><li>事务处理能力 TPS  </li><li>系统资源消耗情况：CPU MEMORY DISK NETWORDK</li></ul><h1 id="性能测试初级"><a href="#性能测试初级" class="headerlink" title="性能测试初级"></a>性能测试初级</h1><p>工具永远只能解决1/3的问题</p><ul><li>性能测试工具：loadrunner、jmeter<br>发送请求  —&gt;  参数化、思考时间、集合点、事务等  —&gt;  设计场景  —&gt;  运行场景  —&gt;  监控指标  —&gt;  结果图标</li></ul><h2 id="性能测试方案"><a href="#性能测试方案" class="headerlink" title="性能测试方案"></a>性能测试方案</h2><ol><li>能够位实施过程提供战术依据，实施过程必须严格遵守方案执行。</li><li>测什么：测试对象（测什么版本），测试范围（关键业务）</li><li>怎么测：接口、脚本、场景、参数、指标、运行策略（测试时间，压力，并发，负载，稳定性）</li><li>数据如何分析，如何定位瓶颈（预测本系统通常瓶颈容易出现在哪里），对指标体系的设计参考</li><li>优化和解决问题（解决方案），回归测试策略。</li><li>人员配置和工作协调。</li><li>软硬件配置清单，工具使用，脚本开发</li></ol><h2 id="性能测试场景"><a href="#性能测试场景" class="headerlink" title="性能测试场景"></a>性能测试场景</h2><ol><li>压力：最大用户数或使劲弄（负载机，客户端瓶颈，（租用云服务器，成本有点高），充分利用云服务器环境的运算能力+网络资源）</li><li>并发：集合点，（伪并发：1000个线程同时发请求，未必能同时到达服务器）。</li><li>负载：到底多少用户是合适的？<ul><li>(通常参考同行的系统，TPS，并发用户数是多少？(不一定需要关心)。如果是已上线系统，可以参考历史记录，历史交易。(Transaction)，但是如果是新上线的呢？（做最好的准备，最坏的打算，先基于业务进行估算，然后上线后实时监控，实时调整）。</li><li>如果在测试环境，测试结果毫无参考价值。最好的解决方案就是在生产环境（公网）直接进行测试。可通过采集测试环境的数据，拟合一条线性回归议程，来预测生产环境对应配置的负载能力。或者将生产环境直接用于测试，将访问域名解析到备用机上，将生产环境隔离出来用于性能测试（建议在深夜执行）。)</li></ul></li><li>长时间在标准负载（最佳用户数）运行（比如一个星期），考察是否支持7*24运行，考察是否存在内存溢出问题。</li></ol><h2 id="性能指标体系"><a href="#性能指标体系" class="headerlink" title="性能指标体系"></a>性能指标体系</h2><p>基于I/O路径来定位硬件和软件</p><ol><li>硬件：CPU，内存，带宽，硬件（路由器、交换机、集群、磁盘阵列、分布式）</li><li>软件：进程所消耗的CPU，内存，进程内部的内存管理，线程池（Pool,避免繁琐的新增和销毁），数据池连接池，缓存策略（缓存是目前最有效提升系统性能的办法之一，但凡有IO的地   方，最好都要使用缓存），算法对CPU的消耗，很多时候需要专门的监控工具</li><li>客户端视角：响应时间，响应内容，成功率，可靠性（稳定运行）</li></ol><h2 id="性能测试分析"><a href="#性能测试分析" class="headerlink" title="性能测试分析"></a>性能测试分析</h2><ol><li>瓶颈，指标的均衡（动态指标变化），用户体验（第一印象，First Impression，首屏加载时间：当执行性能测试时，利用F12同步访问该系统，手工统计即可。Dynatrace Ajax，前端性能分析工具，F12前端性能）。Microfocus，Compuware。</li><li>200并发-&gt;响应时间3s-&gt;服务器-&gt;TPS: 66  -&gt; 增加到500并发-&gt;（TPS:166？）-&gt;响应时间5秒-&gt;系统的处理能力会高于100，响应时间会低于5秒。</li><li>主要利用关联分析，对多个指标按时间进行关联，看是否存在正相关还是不相关。<h2 id="系统性能优化"><a href="#系统性能优化" class="headerlink" title="系统性能优化"></a>系统性能优化</h2></li><li>使用监控工具获取性能细节：内存，JVM，线程，硬盘，CPU，SQL。。。</li><li>server.xml设置Tomcat的线程数。</li><li>可以在catalina.bat文件中设置JVM内存参数。 <a href="https://blog.csdn.net/gududedabai/article/details/81072075" target="_blank" rel="noopener">https://blog.csdn.net/gududedabai/article/details/81072075</a></li><li>配置Tomcat集群。</li></ol><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><ol><li>JavaEE服务器（容器）：IBM: Websphere，Oracle: BEA：WebLogic，Tomcat，Apusic，Resin。</li><li>Web服务器（只处理HTTP请求）：Apache, Nginx，IIS，lighttp。</li><li>数据库：MySQL，PostgreSQL，MariaDB，DB2，Informix，Oracle，SQL Server，MongoDB。 分库，分表。</li><li>高可用（High Availability）：集群Cluster，请求分发，负载均衡(Load-Balance)，Redware，容错处理（Fail-Over）。</li><li>缓存服务器(Redis，MemedCache-内存型非关系型数据库-key:value，使用集群解决数据出问题)，分布式文件系统（FastDFS），磁盘存储阵列，网络文件系统（固态硬盘）。带宽-&gt;CDN服务器。</li><li>分布式开发，微服务，云计算，分布式事务，CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。。。</li><li>高并发，高可用。Redhat: RHEL-&gt;CentOS，MySQL-&gt;MariaDB（OpenJDK）。</li></ol><h1 id="性能测试高级篇"><a href="#性能测试高级篇" class="headerlink" title="性能测试高级篇"></a>性能测试高级篇</h1><ol><li>并发用户数量是一个无法完全精准的数据，需要明确具体的时间段。</li><li>关于并发用户数量的分析：针对已经上线的系统，可以通过日志进行访问记录，进而得出某个合理的时间段内的并发用户数量。但是如果系统是首次上线前的性能测试评估，如何设计合理的并发用户量和场景？<ol><li>通过公开渠道查阅相关的数据资料。</li><li>通过分析竞品寻找相应的参数数据。</li><li>根据需求分析和架构设计的要求，来验证并发用户数量。<br>某个关键事务的响应时间在多少秒内？2-5-8原则：2秒，5秒，8秒，超过8秒。<br>并发用户量（客户端视角）或业务处理量（服务器视角，特定的硬件环境）：<br>Transaction：事务，交易。（服务器视角和客户端视角）。<br>上线后继续收集访问日志，随时调整测试方案和硬件配置。<br>(什么环境，什么配置下）如果并发量和处理量均达标，但是响应时间不达标，此类情况，继续深入分析慢的原因：代码，数据库，算法，带宽，客户端阻塞等。。。。。</li><li>明确地知道用户是什么群体，在哪里，有多少人，按10%做并发折算。</li></ol></li><li>测试环境与生产环境，如果配置不一样，测试环境的数据意义何在？如何解决？</li><li>浏览器的并发线程数量：<a href="https://www.cnblogs.com/sunsky303/p/8862128.html。" target="_blank" rel="noopener">https://www.cnblogs.com/sunsky303/p/8862128.html。</a></li><li>配置基于Tomcat的集群环境：<a href="https://blog.csdn.net/dearfinance/article/details/79907594" target="_blank" rel="noopener">https://blog.csdn.net/dearfinance/article/details/79907594</a><ol><li>负载均衡：Load-Balance，多个节点共同提供服务。</li><li>容错转移：Fail-Over，当一个节点失效时，请求将被转交给其他节点处理。</li></ol></li><li>性能测试也需要同时对功能进行正确性校验，以统计事务的成功率，评估其功能上的稳定性。通常失败率不能够超过3%，尽量在1%。如果超过5%，则必须严格分析和检查，以定位问题。</li></ol><h2 id="模拟真实场景"><a href="#模拟真实场景" class="headerlink" title="模拟真实场景"></a>模拟真实场景</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将代速设备的内容保存到高速设备中，减少对低速的读写</p><ol><li>缓存：页面资源必须要下载，但是通常只下载一次，后面的请求如果有相同的资源，则浏览器本身会从缓存中读取。相对于网络传输和服务器处理的时间来说，浏览器直接读取本地缓存（硬盘或内存）或更快，同时可以显著降低服务器端的I/O消耗。</li><li>如何用Python脚本来实现缓存？第一次下载页面资源后，将资源文件保存到硬盘某个特定目录，下一次再下载资源文件前，先检查一下该资源文件名是否已经存在于硬盘，如果存在，则无需下载。</li><li>在JMeter中，无法精确模拟缓存，要么全部下载，要么不下载。建议全部下载。</li><li>同一个用户才有缓存，不同的用户（并发用户），缓存不可能重复使用。目录：url1、url2。</li><li>5G：4.6G/s   500M/s，  远高于目前的标准硬盘的读写速度，此时还需要缓存吗？</li><li>对于硬盘来说，将内容缓存到内存，也是一种提速的方法。</li></ol><h3 id="网络带宽"><a href="#网络带宽" class="headerlink" title="网络带宽"></a>网络带宽</h3><ol><li>服务器端的出口带宽。</li><li>客户端的访问带宽。</li><li>性能测试实施过程中，要确保负载机（客户端）的并发情况下，客户端的带宽足够。调优（基于I/O路径进行优化）：<ol><li>降低资源文件的大小，减少带宽的占用。</li><li>合理利用各类系统节点的缓存，降低对低速设备的读写频率。</li><li>优化代码算法，降低CPU使用率。</li><li>找到系统的瓶颈所在，对瓶颈进行分析和优化。</li><li>修改系统的核心内存参数，优化内存的使用，降低硬盘的读写。</li></ol></li></ol><h2 id="指标监控与分析"><a href="#指标监控与分析" class="headerlink" title="指标监控与分析"></a>指标监控与分析</h2><ol><li>指标并不是越多越好，关键是找到核心指标，清楚了解该指标的作用。</li><li>巧妇难为无米之炊：一定要基于监控的指标数据进行分析，数据是基础。</li><li>监控工具很多，关键在指标本身。</li><li>对指标的分析：找到指标与指标之间影响关系，分析系统的瓶颈所在。最终目的是解决性能问题。</li><li>请求的处理过程会经历多个步骤，每一个步骤都可能存在瓶颈。</li><li>由于有多个步骤，所以步骤与步骤之间，就会存在动态影响。</li><li>动态影响：<ol><li>假设Tomcat所在服务器出现瓶颈，则此时数据库可能闲着。</li><li>如果解决了Tomcat的瓶颈，数据库有可能成为瓶颈。</li><li>如果解决了Tomcat和数据库的瓶颈，带宽有可能成为新的瓶颈。</li><li>如果带宽问题解决，流量变大，Tomcat或数据库又可能出现更高要求的瓶颈。<br>随着并发用户量的增加，必然导致请求数量增加，资源消耗增加，进而导致响应时间变长，导致处理请求的数量减少，请求队列增加，进而进入恶性循环。（瓶颈）。服务器端的一个关键指标：Timeout超时时间可能会起作用。</li></ol></li></ol><ul><li><p>吞吐量：硬盘，网络，请求，事务，都可以统一表达为吞吐量，单位时间的吞吐量叫吞吐率。</p></li><li><p>事务处理能力-TPS：Transaction Per Second，TPM：Minute。事务的成功率。</p></li><li><p>Tomcat的服务器端状态监控：（修改conf目录下的 tomcat-users.xml文件，最后添加并重启）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"tomcat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"role1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"denny"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">roles</span>=<span class="string">"manager,manager-gui"</span>/&gt;</span>  </span><br><span class="line">//server status登录</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"tomcat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"both"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"tomcat,role1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"role1"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"role1"</span>/&gt;</span></span><br><span class="line">默认情况下，Tomcat的内存分配：Free memory: 19.23 MB Total memory: 49.99 MB Max memory: 247.50 MB，最大的内存是256MB。</span><br><span class="line">Free memory: 19.23 MB：目前可用内存。</span><br><span class="line">Total memory: 49.99 MB：目前Tomcat被分配到的总内存。</span><br><span class="line">Max memory: 247.50 MB：Tomcat可以被分配的最大的内存数量。</span><br><span class="line">修改conf/server.xml，为Connector节点对应的访问端口处添加线程和队列长度：</span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8088"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">"8445"</span> <span class="attr">maxThreads</span>=<span class="string">"100"</span> <span class="attr">acceptCount</span>=<span class="string">"110"</span> /&gt;</span></span><br><span class="line">maxThreads="100"：Tomcat的最大处理线程。</span><br><span class="line">acceptCount="110"：允许排除的长度。</span><br><span class="line">修改catalina.bat，添加一行：</span><br><span class="line">set JAVA_OPTS=-Xms1024M -Xmx1024M -XX:MaxPermSize=1024M</span><br></pre></td></tr></table></figure></li><li><p>MySQL</p><ol><li>MySQL的核心配置参数在Linux的/etc/my.cnf，在Windows上，对应于MySQL的数据目录所在位置，叫my.ini。</li><li>缓冲区大小：<ul><li>query_cache_size=0  # 设置为0表示禁用缓存，不建议使用该设置。</li><li>query_cache_type=1  # 表示打开缓存</li></ul></li><li>MySQL，查找my.ini中的如下三个参数，并修改：<ul><li>slow-query-log=1   # 1表示开启慢查询的监控</li><li>slow_query_log_file=”DESKTOP-0C07AN0-slow.log”    # 将慢SQL写入日志文件中</li><li>long_query_time=1.5   # 1.5表示SQL语句执行时间超过1.5秒的，视为慢查询</li></ul></li><li>内存型数据库：把数据直接全部放到内存中进行DML和DQL。效率极高，速度极快，彻底解决了硬盘瓶颈的问题，但是很难完全商业化？为什么？因为内存不稳定，一个不小心，数据丢失。存储阵列，NAS，RAID，固态硬盘：综合运用，提升硬盘速度。</li></ol></li></ul><h2 id="性能测试方案-1"><a href="#性能测试方案-1" class="headerlink" title="性能测试方案"></a>性能测试方案</h2><p>（目的：根据方案可以很容易实施性能测试）：</p><ul><li>定义标准：关键性能指标，响应时间，事务处理，事务成功率，资源利用率等。</li><li>环境配置：在什么软件和硬件配置下进行性能测试。</li><li>测试范围：关键业务，测什么？用户使用频率最高，并发量最大的业务。</li><li>测试场景：如何设计场景，并发用户量，负载策略，分布式执行策略，数据库容量，客户端和服务器端带宽需求，缓存策略，IP地址（云服务器），思考时间，集合点，生产环境和测试环境。。。。</li><li>测试脚本：如何发送请求，接口规范，检查点，断言，事务，执行顺序。</li><li>性能指标：要监控什么指标。</li><li>回归测试：什么时候回归，如何回归，出现问题的应对措施。</li><li>实施计划。</li></ul><h2 id="性能测试报告"><a href="#性能测试报告" class="headerlink" title="性能测试报告"></a>性能测试报告</h2><ul><li>在现有的测试环境下，是否满足性能需求？</li><li>性能测试过程中，出现了什么问题，如何解决的？</li><li>相应的数据分析和图表，与结论对应。</li><li>改时方案，回归测试后的结果。。。。</li></ul><h2 id="Web前端性能分析"><a href="#Web前端性能分析" class="headerlink" title="Web前端性能分析"></a>Web前端性能分析</h2><ul><li>请求的数量：越少越好，请求越多，浏览器线程等待时间更长，更频繁地建立TCP连接，后台服务器IO的开销更多，考虑合并请求。</li><li>响应时间：越短越好，观察是否有明显的较长的响应时间。</li><li>响应的大小：比如文件，图片，确认是否可以压缩。</li><li>前端代码压缩：CSS，HTML和JS均可以做压缩，降低带宽消耗。</li><li>传输过程压缩：Accept-Encoding: gzip, deflate。</li><li>监控前端JavaScript代码的执行效率：Dynatrace Ajax Editon，或F12的调试。</li><li>监控前端资源配合测试：为了更好地配合前后端性能测试，当正在进行后端性能测试时（高并发的时候），此时利用F12或Fiddler等前端分析工具对整个通信过程进行监控。</li><li>First-Impression：第一印象，首屏加载时间。响应时间很长，并不代表首屏时间很长，而用户最直观的感受是首屏加载时间。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础命令</title>
      <link href="/2018/09/06/linux/"/>
      <url>/2018/09/06/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux树形结构目录"><a href="#Linux树形结构目录" class="headerlink" title="Linux树形结构目录"></a>Linux树形结构目录</h2><table><thead><tr><th>/</th><th>根目录</th></tr></thead><tbody><tr><td>├── bin</td><td>存放用户二进制文件</td></tr><tr><td>├── boot</td><td>存放内核引导配置文件</td></tr><tr><td>├── dev</td><td>存放设备文件</td></tr><tr><td>├── etc</td><td>存放系统配置文件</td></tr><tr><td>├── home</td><td>用户主目录</td></tr><tr><td>├── lib</td><td>动态共享库</td></tr><tr><td>├── lost+found</td><td>文件系统恢复时的恢复文件</td></tr><tr><td>├── media</td><td>可卸载存储介质挂载点</td></tr><tr><td>├── mnt</td><td>文件系统临时挂载点</td></tr><tr><td>├── opt</td><td>附加的应用程序包</td></tr><tr><td>├── proc</td><td>系统内存的映射目录，提供内核与进程信息</td></tr><tr><td>├── root</td><td>root 用户主目录</td></tr><tr><td>├── sbin</td><td>存放系统二进制文件</td></tr><tr><td>├── srv</td><td>存放服务相关数据</td></tr><tr><td>├── sys</td><td>sys   虚拟文件系统挂载点</td></tr><tr><td>├── tmp</td><td>存放临时文件</td></tr><tr><td>├── usr</td><td>存放用户应用程序</td></tr><tr><td>└── var</td><td>存放邮件、系统日志等变化文件</td></tr></tbody></table><h1 id="linux基础命令"><a href="#linux基础命令" class="headerlink" title="linux基础命令"></a>linux基础命令</h1><p>####　杀进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps -ef | grep *  # 查找进程ID</span><br><span class="line"><span class="meta">$</span> ps -e --forest | grep * # 显示进程数</span><br><span class="line"><span class="meta">$</span> kill - 9 ID  # 杀死当前进程的ID</span><br><span class="line">－－－－－－－－－－－－－－－－－－</span><br><span class="line"><span class="meta">$</span> killall -9 * # 直接杀死当前进程（包含这个进程的所有ID）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Signal Name</th><th align="center">Single Value</th><th align="center">Effect</th></tr></thead><tbody><tr><td align="center">SIGHUP</td><td align="center">1</td><td align="center">挂起</td></tr><tr><td align="center">SIGINT</td><td align="center">2</td><td align="center">键盘的中断信号</td></tr><tr><td align="center">SIGKILL</td><td align="center">9</td><td align="center">发出杀死信号</td></tr><tr><td align="center">SIGTERM</td><td align="center">15</td><td align="center">发出终止信号</td></tr><tr><td align="center">SIGSTOP</td><td align="center">17,19,23</td><td align="center">停止进程</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python连接Mysql</title>
      <link href="/2018/08/12/Python%E8%BF%9E%E6%8E%A5Mysql/"/>
      <url>/2018/08/12/Python%E8%BF%9E%E6%8E%A5Mysql/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">STEP1:引包： <span class="comment">#pip install pymql</span></span><br><span class="line">Import pymySQL</span><br><span class="line"></span><br><span class="line">STEP2:通过模块调用对应的方法获取一个连续的函数</span><br><span class="line"><span class="comment">#指明连接的数据库（host、user、password、databasesname、charset）</span></span><br><span class="line">con = pymysql.connect (                                           )</span><br><span class="line"></span><br><span class="line">STEP3:用连接对象调用方法获取一个可执行对象</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">STEP4:执行SQL语句</span><br><span class="line">sql = （语句）</span><br><span class="line">cur.execute(sql)</span><br><span class="line">con.commit()</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment">#cur.fetchone()  # 获取元组第一个元素</span></span><br><span class="line"><span class="comment">#cur.fetchall() # 获取元组剩余的元素</span></span><br><span class="line"><span class="comment">#cur.fetchmany() # 获取全部元素</span></span><br><span class="line">------------------------------------------</span><br><span class="line"></span><br><span class="line">STEP5:关闭连接</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2018/08/10/MYSQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/10/MYSQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="mySQL基础"><a href="#mySQL基础" class="headerlink" title="mySQL基础"></a>mySQL基础</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>结构化查询语言，是常用操作数据库的计算机语言。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>非结构化</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>DQL：数据查询语言：<br>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句构成的查询块：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>&lt;字段表名&gt;、<span class="keyword">FROM</span>&lt;表或视图名&gt;、<span class="keyword">WHERE</span>&lt;查询条件&gt;</span><br></pre></td></tr></table></figure></li><li><p>DML：数据操作语言：<br>数据操作语言的DML主要的三种形式：插入：INSERT、更新：UPDATE、删除：DELETE</p></li><li><p>DDL：数据定义语言：<br>数据定义语言DDL用来创建数据库的各种对象—–表、视图、索引、同义词、聚簇等如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> (表) / <span class="keyword">VIEW</span> (视图) / <span class="keyword">INDEX</span> （索引）/ SYN（同义词）/ CLUSTER（簇）</span><br><span class="line"><span class="keyword">DDL</span>操作为隐形提交！不能<span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure></li><li><p>DCL：数据控制语言</p><h2 id="数据库字符类型"><a href="#数据库字符类型" class="headerlink" title="数据库字符类型"></a>数据库字符类型</h2><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节整数类型，范围约+/-21亿</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节整数类型，范围约+/-922亿亿</td></tr><tr><td>FLOAT</td><td>浮点型</td><td>4字节浮点数，范围约+/-1038</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节浮点数，范围约+/-10308</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>存储True或者False</td></tr><tr><td>DATE</td><td>日期类型</td><td>存储日期，例如，2018-06-22</td></tr><tr><td>TIME</td><td>时间类型</td><td>存储时间，例如，12:20:59</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table></li></ul><h2 id="数据库常用操作"><a href="#数据库常用操作" class="headerlink" title="数据库常用操作"></a>数据库常用操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看数据库： <span class="keyword">SHOW</span> <span class="keyword">DATABASES</span></span><br><span class="line">删除数据库： <span class="keyword">DROP</span> <span class="keyword">DATABASE</span>（数据库名）</span><br><span class="line">创建数据库： <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> （数据库名）</span><br><span class="line">创建表： <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> （表名）（)</span><br><span class="line">查看所有表： <span class="keyword">SHOW</span> <span class="keyword">TABLES</span></span><br><span class="line">修改表名： <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> （旧表名）<span class="keyword">RENAME</span>（新表名）</span><br><span class="line">添加列：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>（表名）<span class="keyword">ADD</span> <span class="keyword">COLUMN</span> （列名；列属性）</span><br><span class="line">修改列：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span>（表名）CHANG （旧列名；新列名；新列名属性）</span><br><span class="line">删除列：<span class="keyword">ALTER</span> （表名）<span class="keyword">DROP</span>（列名）</span><br></pre></td></tr></table></figure><h3 id="CHANG-和-MODIFY-的区别"><a href="#CHANG-和-MODIFY-的区别" class="headerlink" title="CHANG 和 MODIFY 的区别"></a>CHANG 和 MODIFY 的区别</h3><ul><li>change用来字段重命名，不能修改字段类型和约束；</li><li>modify不用来字段重命名，只能修改字段类型和约束；</li></ul><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>数据有效性 + 数据类型准确性 = 数据完整性                                                                       </p><ul><li>数据完整性包含<ul><li>实体、域（列）、引用、自定义</li></ul></li></ul><h2 id="六大约束"><a href="#六大约束" class="headerlink" title="六大约束"></a>六大约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul><li>保证实体的完整性</li><li>为表中一列或几列的组合</li><li>作用：设置主键约束，如果是单列则该列不能出现重复性数据，如果是联合主键那么不允许几列中出现完全一样的数据</li><li>使用：定义表的时候设置主键 PRIMARY KEY<ul><li>如果表已经定义，那么可以额外的添加约束：ALTER TABLE（表名）ADD PRIMARY KEY （某列）</li></ul></li><li>注意：一张表只能有一个主键约束</li></ul><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li>体现了引用完整性</li><li>定义：为某表的其中一列</li><li>作用：添加了外键约束的列中的数据只能来自于另一张表中某列（一般是某表的主键）</li><li>使用：<ul><li>定义表的时候：FOREIGN KEY（列名）REFERENCES（表名、列名）<ul><li>已定义的时候：ALTER TABLE（表名）ADD FOREIGN KEY（列名）REFERENCES（表名、列名）</li></ul></li></ul></li><li>注意：<ul><li>一张表中可以有多个外键</li><li>保证数据库和表的引擎innodb</li><li>被引用的列数据类型要和外键一致</li></ul></li></ul><h3 id="自增长约束"><a href="#自增长约束" class="headerlink" title="自增长约束"></a>自增长约束</h3><ul><li>体现实体、列完整性</li><li>定义：给表中主键列设置自增长</li><li>作用：自动填充数据、填充的数据是上一条数据的基础上自增1 </li><li>使用：auto_increment</li><li>注意：结合主键一起使用；该列是整数类型</li></ul><h3 id="唯一"><a href="#唯一" class="headerlink" title="唯一"></a>唯一</h3><ul><li>体现了实体完整性</li><li>定义：给表中任意字段条件唯一约束</li><li>作用：添加了唯一约束的列不能出现重复值</li><li>使用：UNIQUE</li><li>注意：表中任何一列都可以使用，也可以同时对表中多列添加唯一约束 </li></ul><h3 id="非空"><a href="#非空" class="headerlink" title="非空"></a>非空</h3><ul><li>体现了列完整性</li><li>定义：给表中一列添加非空约束</li><li>作用：设置了非空约束列的数据不能为空</li><li>使用：NOT NULL</li><li>注意：表中任何一列都可以使用，也可以同时对表中多列添加非空约束                                                                                                                           </li></ul><h3 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h3><ul><li>体现了列完整性</li><li>定义：给某列设置默认约束</li><li>作用：设置了默认约束的列有默认值    </li><li>使用：DEFAULT默认值</li><li>注意：表中任何一列都可以用，也可以同时对表中多列添加非空约束</li></ul><h2 id="数据库设计三大范式"><a href="#数据库设计三大范式" class="headerlink" title="数据库设计三大范式"></a>数据库设计三大范式</h2><ul><li>确保每列的原子性：确保表中的每一列都不可再拆分为更细小的列</li><li>每个实列或行必须可以被唯一的拆分：确保每个表都有主键列</li><li>确保每个列都有主键列直接相关，而不是间接相关：确保表中不能有其他表的非主键列</li></ul><h2 id="SQL执行各子句的顺序"><a href="#SQL执行各子句的顺序" class="headerlink" title="SQL执行各子句的顺序"></a>SQL执行各子句的顺序</h2><p><strong>from  where  group by  having  order by  limit</strong> </p><ol><li>首先执行FROM子句，将FROM子句中的表做为中间表；</li><li>如果有WHERE子句，则根据其中的过滤条件，从中间表中去掉不满足过滤条件的行。</li><li>如果有GROUP BY子句，根据GROUP BY子句中指定的分组列，对中间表中的数据进行分组。</li><li>为每个组计算SELECT子句聚合函数的值，并为每组生成查询结果中的一行。</li><li>如果有HAVING子句，则根据HAVING子句的过滤条件，分组计算聚合计算的结果再次过滤。</li><li>如果有ORDER BY子句中，则根据ORDER BY子句中的列，对结果集进行排序 ，最后是limit 。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unittest框架</title>
      <link href="/2018/08/02/Unittest%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/08/02/Unittest%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Unittest框架"><a href="#Unittest框架" class="headerlink" title="Unittest框架"></a>Unittest框架</h2><ul><li>python自带的单元测试框架，java自带的单元框架Junit</li><li>单元测试的本质：代码测试代码；原理：调用源代码，对比预期结果和实际结果</li><li>特别注意：unittest 框架识别被测代码的方式：测试代码方法名需以test开头</li></ul><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setUP() <span class="comment"># 初始化；特点：每一条测试用例执行前就会执行初始化</span></span><br><span class="line">tearDown() <span class="comment"># 资源回收；特点：每一条测试用例执行后就会执行资源回收  </span></span><br><span class="line">setUpClass() <span class="comment"># 初始化；特点：所有测试用例执行前执行初始化</span></span><br><span class="line">tearDownClass() <span class="comment"># 资源回收；特点：所有用例执行后执行资源回收</span></span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assertEqual(a,b,msg)a == b</span><br><span class="line">assertGreater(a,b,msg)     a &gt; b</span><br><span class="line">assertLess(a,b,msg)  a &lt; b</span><br></pre></td></tr></table></figure><h2 id="TestSuite-测试集"><a href="#TestSuite-测试集" class="headerlink" title="TestSuite 测试集"></a>TestSuite 测试集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">suite = unittest,TestSuite() <span class="comment"># 实例化测试集</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromTestCase( 类名 ))<span class="comment"># 加载整个类中的测试用例进入测试集</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(‘模块名.类名.方法名’))<span class="comment"># 记载指定某个模块下的某个类下的方法/用例</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(‘模块名.类名’)) <span class="comment"># 加载整个类中的测试用例进入测试集</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromModule(模块名))<span class="comment"># 加载整个模块的测试用例进入测试集，特别注意：需要导入本模</span></span><br><span class="line">runner=unittest.TextTestRunner(verbosity=<span class="number">2</span>)<span class="comment"># 实例化一个runner, verbosity：结果复杂度</span></span><br><span class="line">runner.run(suite)<span class="comment"># 执行测试集</span></span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@unittest.skip# 强制跳过</span></span><br><span class="line"><span class="meta">@unittest.skipIf(1&lt;2,reason='1&lt;2,跳过')# 满足条件就跳过，True-跳过</span></span><br><span class="line"><span class="meta">@unittest.skipUnless(2&lt;1,reason='1&lt;2,跳过')# 不满足条件就跳过，False-跳过</span></span><br></pre></td></tr></table></figure><h2 id="TestResult"><a href="#TestResult" class="headerlink" title="TestResult"></a>TestResult</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suite=unittest.TestSuite()<span class="comment"># 实例化测试集</span></span><br><span class="line">suite.addTest(calc_Test(<span class="string">'test_add01'</span>))<span class="comment"># 加载单个测试用例到测试集中</span></span><br><span class="line">r=unittest.TestResult()<span class="comment"># 实例化一个测试结果用于存储测试结果</span></span><br><span class="line">suite.run(result=r)<span class="comment"># 以测试集方式执行测试</span></span><br></pre></td></tr></table></figure><h2 id="TestRunner"><a href="#TestRunner" class="headerlink" title="TestRunner"></a>TestRunner</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suite=unittest.TestSuite()<span class="comment"># 实例化测试集</span></span><br><span class="line">suite.addTest(calc_Test(<span class="string">'test_add01'</span>))<span class="comment"># 加载单个测试用例到测试集中</span></span><br><span class="line">unittest.TextTestRunner().run(suite)<span class="comment"># 执行测试集</span></span><br></pre></td></tr></table></figure><h2 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统自带生成报告</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'report.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    unittest.TextTestRunner(stream=file,verbosity=<span class="number">2</span>).run(suite)</span><br><span class="line"><span class="comment"># 利用第三方库HTMLTestRunner</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'report.html'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    HTMLTestRunner(stream=file,verbosity=<span class="number">2</span>,title=<span class="string">'测试报告'</span>,description=<span class="string">'计算器的测试报告'</span>).run(suite)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口测试基础</title>
      <link href="/2018/08/02/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/02/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="借口测试基础"><a href="#借口测试基础" class="headerlink" title="借口测试基础"></a>借口测试基础</h1><h2 id="接口测试概念"><a href="#接口测试概念" class="headerlink" title="接口测试概念"></a>接口测试概念</h2><ul><li>代码级接口测试的基本原理：调用源代码，比较预期结果与实际结果</li><li>协议级接口测试的基本原理：模拟协议的通讯过程，建立通讯的连接，发请求，获取响应，对相应结果进行断言（实际结果和预期结果对比）</li><li>接口测试的方法：利用黑盒测试方法，脚本实现测试</li><li>接口测试的优势：较UI比较稳定，后期代码维护的成本比较低，门槛低（简单易学），自动化实施落实落地比较靠谱</li><li>接口测试的劣处：需要模拟的参数比较多，比较繁杂；加密复杂的接口难以实现接口测试，借助开发已经写好的加密方法来实施</li><li>常见自动化测试的类型：UI自动化、接口自动化、性能自动化、安全自动化等</li><li>TDD（test-Driven Development），测试先行，质量为天</li></ul><h2 id="协议参考模型"><a href="#协议参考模型" class="headerlink" title="协议参考模型"></a>协议参考模型</h2><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>7层模型：</p><ul><li>应用层 – 协议：HTTP、Telnet、FTP、SOAP、SMTP（simple Mail Transfer Protocol - 简单邮件传输协议）等</li><li>表示层 – 协议：JPEG、GIF等</li><li>会话层 – 协议：RPC（Remote Procedure Call）—远程过程调用</li><li>传输层 – 协议：TCP（Transmission Control Protocol –传输控制协议）、UDP（User Datagram Protocol-用户数据报协议）等</li><li>网络层 – 协议：IP（Internet Protocol）、ICMP协议、IGMP协议、ARP协议等</li><li>数据链路层 – 协议：PPP：点对点协议(Point to Point Protocol)等</li><li>物理层 – 协议：RS232等<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3>4层模型：</li><li>应用层 – 协议：HTTP、Telnet、FTP、SMTP（Simple Mail Transfer Protocol-简单邮件传输协议）等</li><li>传输层 – 协议：TCP（Transmission Control Protocol –传输控制协议）、UDP（User Datagram Protocol-用户数据报协议）等</li><li>网络层 – 协议：IP协议、ICMP协议、IGMP协议、ARP协议</li><li>网络访问层</li></ul><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>面向连接、可靠的、基于字节流、三次握手 - 建立连接 ；四次挥手 - 关闭连接；安全，但费事费资源</p><h3 id="三次握手：SYN"><a href="#三次握手：SYN" class="headerlink" title="三次握手：SYN"></a>三次握手：SYN</h3><ul><li>第一次握手：主机A发送位码为SYN＝1,随机产生seq number=200的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</li><li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),SYN=1,ACK=1,随机产生seq number=500的包；</li><li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ACK是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。<h3 id="四次挥手：FIN"><a href="#四次挥手：FIN" class="headerlink" title="四次挥手：FIN"></a>四次挥手：FIN</h3></li><li>第一次挥手：客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 </li><li>第二次挥手：服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。</li><li>第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 </li><li>第四次挥手：客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。<h3 id="Python模拟TCP通信"><a href="#Python模拟TCP通信" class="headerlink" title="Python模拟TCP通信"></a>Python模拟TCP通信</h3>建立连接(connect)—传送数据(send)—关闭连接(close)                          <h3 id="小结TCP与UDP的区别"><a href="#小结TCP与UDP的区别" class="headerlink" title="小结TCP与UDP的区别"></a>小结TCP与UDP的区别</h3></li></ul><ol><li>基于连接与无连接；</li><li>对系统资源的要求（TCP较多，UDP少）；</li><li>UDP程序结构较简单；</li><li>流模式与数据报模式 ；</li><li>TCP保证数据正确性，UDP可能丢包；</li><li>TCP保证数据顺序，UDP不保证。    </li></ol><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>User Datagram Protocol （用户数据报协议）无连接、不可靠，优点：快，性能好<br>Python模拟UDP协议—飞秋：IPMSG的报文格式：版本号: 包编号: 发送者姓名: 发送者主机名: 命令字: 附加信息</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>Internet Protocol<br>网络层代表协议 - 待补充</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>Hypertext Transfer Protocol 超文本传输协议</p><ul><li>URL-组成：协议+主机名+端口号+资源位置+请求的参数+hash tag(锚地址)，<a href="http://baidu:80/path/?q=a#hash" target="_blank" rel="noopener">http://baidu:80/path/?q=a#hash</a></li><li>工作过程：地址解析–封装HTTP请求数据包—封装成TCP包，建立TCP连接—客户机发送请求命令–服务器响应–服务器关闭TCP连接–浏览器渲染展示页面</li></ul><h3 id="http的会话过程"><a href="#http的会话过程" class="headerlink" title="http的会话过程"></a>http的会话过程</h3><p>1.建立tcp连接<br>2.发出请求文档<br>3.发出响应文档<br>4.释放tcp连接</p><h3 id="HTTP方法的性质"><a href="#HTTP方法的性质" class="headerlink" title="HTTP方法的性质"></a>HTTP方法的性质</h3><ul><li>Safe - 安全<br>这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此RFC定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用GET修改用户信息的情况。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。</li><li>Idempotent - 幂等<br>幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照RFC规范，PUT，DELETE和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。</li><li>Cacheable - 可缓存性<br>顾名思义就是一个方法是否可以被缓存，此RFC里GET，HEAD和某些情况下的POST都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持GET和HEAD。关于缓存的更多内容可以去看RFC7234。<h3 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h3>参数的位置、参数传递的安全性、参数是否缓存、参数的编码格式、使用习惯的不同<h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3></li><li>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li><li>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可  以验证客户端的身份。    </li></ul><h2 id="SOAP协议"><a href="#SOAP协议" class="headerlink" title="SOAP协议"></a>SOAP协议</h2><p>Simple Object Access protocol 简单对像访问协议</p><ul><li>待补充</li></ul><h2 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h2><p>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p><h3 id="协议特点："><a href="#协议特点：" class="headerlink" title="协议特点："></a>协议特点：</h3><p>1.建立在 TCP 协议之上，服务器端的实现比较容易。<br>2.与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>3.数据格式比较轻量，性能开销小，通信高效。<br>4.可以发送文本，也可以发送二进制数据。<br>5.没有同源限制，客户端可以与任意服务器通信。<br>6.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL.</p><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><ul><li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑*到安全应当使用session</li><li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li><li>单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</li><li>建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</li><li>session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息</li><li>session中保存的是对象，cookie中保存的是字符串</li><li>session不能区分路径，同一个用户在访问一个网站期间，所有的- session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python+Selenium</title>
      <link href="/2018/07/19/Selenium%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/19/Selenium%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="WebDriver方法"><a href="#WebDriver方法" class="headerlink" title="WebDriver方法"></a>WebDriver方法</h2><p>WebDriver对象有好几种方法，用于在页面中寻找元素。它们被分成find_element_<em>和find_elements_</em>方法。find_element_<em>方法返回一个 WebElement 对象，代表页面中<br>匹配查询的第一个元素。find_elements_</em>方法返回 WebElement_*对象的列表，包含页面中所有匹配的元素。<br>selenium 的 WebDriver 方法，用于寻找元素：</p><table><thead><tr><th>方法名</th><th>返回的 WebElement 对象/列表</th></tr></thead><tbody><tr><td>browser.find_element_by_class_name(name)</td><td>使用 CSS 类 name 的元素</td></tr><tr><td>browser.find_elements_by_class_name(name)</td><td>-</td></tr><tr><td>browser.find_element_by_css_selector(selector)</td><td>匹配 CSS selector 的元素</td></tr><tr><td>browser.find_elements_by_css_selector(selector)</td><td>-</td></tr><tr><td>browser.find_elements_by_link_text(text)</td><td>完全匹配提供的 text 的<a>元素</a></td></tr><tr><td>browser.find_element_by_link_text(text)</td><td>-</td></tr><tr><td>browser.find_elements_by_partial_link_text(text)</td><td>包含提供的 text 的<a>元素</a></td></tr><tr><td>browser.find_element_by_partial_link_text(text)</td><td>-</td></tr><tr><td>browser.find_element_by_name(name)</td><td>匹配 name 属性值的元素</td></tr><tr><td>browser.find_elements_by_name(name)</td><td>-</td></tr><tr><td>browser.find_element_by_tag_name(name)</td><td>匹配标签 name 的元素</td></tr><tr><td>browser.find_elements_by_tag_name(name)</td><td>(大小写无关，<a>元素匹配’a’和’A’)</a></td></tr></tbody></table><h2 id="WebElement"><a href="#WebElement" class="headerlink" title="WebElement"></a>WebElement</h2><p>WebElement 的属性和方法</p><table><thead><tr><th>属性或方法</th><th>描述</th></tr></thead><tbody><tr><td>tag_name</td><td>标签名，例如 ‘a’表示<a>元素</a></td></tr><tr><td>get_attribute(name)</td><td>该元素 name 属性的值</td></tr><tr><td>Text</td><td>该元素内的文本，例如<span>hello</span>中的’hello’</td></tr><tr><td>clear()</td><td>对于文本字段或文本区域元素，清除其中输入的文本</td></tr><tr><td>is_displayed()</td><td>如果该元素可见，返回 True，否则返回 False</td></tr><tr><td>is_enabled()</td><td>对于输入元素，如果该元素启用，返回 True，否则返回 False</td></tr><tr><td>is_selected()</td><td>对于复选框或单选框元素，如果该元素被选中，选择 True，否则返回 False</td></tr><tr><td>Location</td><td>一个字典，包含键’x’和’y’，表示该元素在页面上的位置</td></tr></tbody></table><h2 id="模拟键盘侠"><a href="#模拟键盘侠" class="headerlink" title="模拟键盘侠"></a>模拟键盘侠</h2><p>selenium 有一个模块，针对不能用字符串值输入的键盘击键。它的功能非常类似于转义字符。这些值保存在 selenium.webdriver.common.keys 模块的属性中。<br>由于这个模块名非常长，所以在程序顶部运行 from selenium.webdriver. common.keys importKeys 就比较容易。<br>如果这么做，原来需要写 from selenium. webdriver.common.keys 的地方，就只要写 Keys。<br>selenium.webdriver.common.keys 模块中常用的变量：</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>Keys.DOWN, Keys.UP, Keys.LEFT,Keys.RIGHT</td><td>键盘箭头键</td></tr><tr><td>Keys.ENTER, Keys.RETURN</td><td>回车和换行键</td></tr><tr><td>Keys.HOME, Keys.END,Keys.PAGE_DOWN,Keys.PAGE_UP</td><td>Home 键、End 键、PageUp 键和 Page Down 键</td></tr><tr><td>Keys.ESCAPE, Keys.BACK_SPACE,Keys.DELETE</td><td>Esc、Backspace 和字母键</td></tr><tr><td>Keys.F1, Keys.F2, . . . , Keys.F12</td><td>键盘顶部的 F 1 到 F 12 键</td></tr><tr><td>Keys.TAB</td><td>Tab 键</td></tr></tbody></table><h2 id="模拟浏览器按钮"><a href="#模拟浏览器按钮" class="headerlink" title="模拟浏览器按钮"></a>模拟浏览器按钮</h2><p>selenium 也可以模拟点击各种浏览器按钮</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>browser.back()</td><td>点击“返回”按钮</td></tr><tr><td>browser.forward()</td><td>点击“前进”按钮</td></tr><tr><td>browser.refresh()</td><td>点击“刷新”按钮</td></tr><tr><td>browser.quit()</td><td>点击“关闭窗口”按钮</td></tr></tbody></table><h2 id="selenium的等待方式"><a href="#selenium的等待方式" class="headerlink" title="selenium的等待方式"></a>selenium的等待方式</h2><ul><li>隐式等待：implicitly_wait(xx)  #xx填写隐式等待的时间</li><li>显示等待：Webdriver参数和方法：selenium.webdriver.support.wait.WebDriverWait（类）</li></ul><table><thead><tr><th><strong>init</strong></th><th></th></tr></thead><tbody><tr><td>driver</td><td>传入WebDriver实例，即我们上例中的driver</td></tr><tr><td>timeout</td><td>超时时间，等待的最长时间（同时要考虑隐性等待时间</td></tr><tr><td>poll_frequency</td><td>调用until或until_not中的方法的间隔时间，默认是0.5秒</td></tr><tr><td>ignored_exceptions</td><td>忽略的异常，如果在调用until或until_not的过程中抛出这个元组中的异常，则不中断代码，继续等待，如果抛出的是这个元组外的异常，则中断代码，抛出异常默认只有NoSuchElementException。</td></tr><tr><td>until</td><td></td></tr><tr><td>method</td><td>在等待期间，每隔一段时间调用这个传入的方法，直到返回值不是False</td></tr><tr><td>message</td><td>如果超时，抛出TimeoutException，将message传入异常</td></tr><tr><td>until_not</td><td>与until相反，until是当某元素出现或什么条件成立则继续执行</td></tr></tbody></table><p><strong>WebDriverWait(driver, 超时时长, 调用频率, 忽略异常).until(可执行方法, 超时时返回的信息)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">"http://somedomain/url_that_delays_loading"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">"myDynamicElement"</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h2 id="下拉框处理"><a href="#下拉框处理" class="headerlink" title="下拉框处理"></a>下拉框处理</h2><p>利用Select模块处理下拉框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line">Select提供了三种选择某一项的方法</span><br><span class="line">select_by_index通过索引定位；index索引是从“<span class="number">0</span>”开始；</span><br><span class="line">select_by_value通过value值定位；value是option标签的一个属性值，并不是显示在下拉框中的值；</span><br><span class="line">select_by_visible_text通过文本值定位；visible_text是在option标签中间的值，是显示在下拉框的值；</span><br><span class="line">Select(下拉框定位).select_by_(三种方法之一)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Appium参数</title>
      <link href="/2018/06/10/Appium%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/06/10/Appium%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Appium参数"><a href="#Appium参数" class="headerlink" title="Appium参数"></a>Appium参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">desired_caps = &#123;&#125;  <span class="comment"># 定义webdriver的兼容性设置字典对象</span></span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span>  <span class="comment"># 指定测试Android平台</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = version  <span class="comment"># 指定移动端的版本号</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'Appium'</span> <span class="comment"># 指定设备名称</span></span><br><span class="line"><span class="comment"># desired_caps['automationName'] = 'uiautomator2'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.mobivans.onestrokecharge'</span>  <span class="comment"># 指定要启动的包</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'com.stub.stub01.Stub01'</span>  <span class="comment"># 指定启动的主类程序</span></span><br><span class="line">desired_caps[<span class="string">'unicodeKeyboard'</span>] = <span class="string">'True'</span>  <span class="comment"># 使用中文输入法</span></span><br><span class="line">desired_caps[<span class="string">'udid'</span>] = udid <span class="comment"># 指定模拟器设备编号(adb devices输出结果)</span></span><br><span class="line">desired_caps[<span class="string">'noReset'</span>] = <span class="string">'True'</span>  <span class="comment"># 不重置应用程序的状态，默认为false</span></span><br></pre></td></tr></table></figure><p>Appium内置的配置参数非常多，主要分为两大类。一类是命令行启动参数，主要用于在命令行启动Appium服务器的时候指定的参数。一类是脚本开发时的兼容性设置参数，如前一节内容中的desired_caps字典对象指定的参数值。两种类别的参数有些是可以互相代替的，比如在启动命令中未指定，而通过字典对象在脚本中指定，结果一样。先来看看两种类型的参数中比较重要的参数。<br>命令行启动参数</p><ul><li>-a 绑定的IP地址：如appium –a 192.168.1.5，默认不指定的情况下为localhost，也即是127.0.0.1，适用于为本机脚本提供连接。当然，我们也可以让测试脚本连接远程Appium服务器。</li><li>-p 服务器端口号：Appium服务器启动时绑定的端口号，用于脚本的通信，默认值为4723。此处需要注意的是，一个端口号只能服务于一台移动设备，如果我们需要同时对多台针对设备进行测试，那么则需要启动多个Appium服务器，每一个服务器实例需要绑定不同的端口号。</li><li>-bp 连接移动端设备的端口号，即Bootstrap端口，默认值为4724。如果需要连接多台移动设备，则需要启动不同端口的Appium服务器并且指定不同的设备端口号。即需要单独为不同的设备，启动不同端口的Appium服务器，并且指定不同的Bootstrap端口号，否则会导致冲突。</li><li>–app 应用程序路径：指定调试模式下的iOS应用或标准的Android系统的APK应用程序的路径，通常情况下不建议在启动时指定，而是在测试脚本中通过字典对象来指定应用程序路径。如果是针对非调试模式下的iOS设备，则对应参数为–ipa。如果已经在手机上安装了相应的应用，则勿需指定，只需要通知移动端代理启动应用即可。</li><li>–app-pkg：指定要测试的应用程序的主包名，与测试脚本中指定的功能一致。该参数仅Android端适用。</li><li>–app-activity：指定要测试的应用程序的主类名，与测试脚本中指定的功能一致。该参数仅Android端适用。</li><li>-U 设备编号：在启动时直接指定当前服务器连接到哪个设备终端。其编号可以从命令“adb devices”的输出列表中获取。一台设备，当连接上电脑后一定有一台唯一的编号。也可以通过参数“–udid”指定，二者效果一致。</li><li>–session-override：当连接过程出现Session冲突的时候，允许被覆盖。目前使用情况较少。</li><li>–full-reset：完全重置被测试应用程序的状态，包括将测试应用程序全部删除。</li><li>–no-reset：不重置状态，不删除应用。</li><li>-g 日志文件：将Appium运行过程的日志输出到指定的日志文件中，便于后续查看。通常情况下，在正式进行测试的过程，我们最好将日志输出到文件，便于永久保存和后续分析。该参数也可以使用“–log”代替。</li><li>–log-timestamp：在终端输出里显示时间戳，便于更好地知道日志输出的时间。</li><li>–log-level：在终端里输出的日志级别，可以设置为debug，info，warn，error等级别。</li><li>–device-name：指定待测试的移动设备的名称，也可在测试脚本中指定。</li><li>–platform-name：指定移动设备对应的平台的名称，如Android或iOS，也可在测试脚本中指定。</li><li>–platform-version：指定移动设备系统对应的版本号，如4.4.2，也可在测试脚本中指定。<br>比如可以通过以下命令启动Appium，来指定IP地址，端口号，Bootstrap端口号，设备编号，不重置状态，输出时间戳在日志中，覆盖Session连接状态，并将日志信息输出到指定的日志文件中进行永久保存：appium -a 127.0.0.1 -p 4723 –bp 4724 –U 127.0.0.1:62001 –no-reset –session-override –log-timestamp –log D:\appium.log</li></ul><h2 id="测试脚本字典参数"><a href="#测试脚本字典参数" class="headerlink" title="测试脚本字典参数"></a>测试脚本字典参数</h2><p>(platformName、platformVersion、deviceName、app、browserName、udid、noReset、appActivity、appPackage、unicodeKeyboard)<br>在测试脚本中的字典参数有很多与命令行参数功能类似，只是参数名称不一样，现列举如下：</p><ul><li>automationName：指定自动化测试引擎，可以是Appium (默认) 或 Selendroid。如果是较新的Android版本，如6.0以上，则必须明确指定automationName=’ uiautomator2’。</li><li>platformName：指定要测试的手机操作系统，如：iOS，Android或FirefoxOS。</li><li>platformVersion：移动操作系统版本，如4.4.2。</li><li>deviceName：使用的手机类型或模拟器类型。在iOS中，必须使用“instruments -s devices”命令得到的设备编号。</li><li>app：指定待测试应用程序。</li><li>browserName：如果是针对手机上的浏览器应用进行测试，需要指定其浏览器名称。在iOS上可用“Safari”，在Android上可指定“Chrome”，“Chromium”或“Browser”。</li><li>newCommandTimeout：设置命令超时时间，单位：秒。达到超时时间仍未接收到新的命令时Appium 会假设客户端退出然后自动结束会话。</li><li>autoLaunch：Appium是否需要自动安装和启动应用，默认值为true。</li><li>udid：连接的移动设备的唯一设备标识</li><li>autoWebview：直接转换到 WebView 上下文。 默认值为false。</li><li>noReset：不要在会话前重置应用状态，默认为false。</li><li>fullReset：在会话结束后自动清除被测应用，默认为false。</li><li>appActivity：应用包中启动的 Android Activity 主类名称。它通常需要在前面添加“.”。</li><li>appPackage：想运行的Android应用程序的主包名。</li><li>deviceReadyTimeout：设置等待一个模拟器或真机准备就绪的超时时间。</li><li>unicodeKeyboard：设置使用Unicode输入法，这样才能支持中文输入。</li><li>resetKeyboard：在使用了unicodeKeyboard参数后，对其进行重置，还原为默认设置。<br>完整的参数列表，访问Appium官方网站查阅：<a href="http://appium.io/docs/en/writing-running-appium/caps/" target="_blank" rel="noopener">http://appium.io/docs/en/writing-running-appium/caps/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ADB常用命令</title>
      <link href="/2018/06/03/ADB%20shell/"/>
      <url>/2018/06/03/ADB%20shell/</url>
      
        <content type="html"><![CDATA[<h1 id="adb-shell-命令"><a href="#adb-shell-命令" class="headerlink" title="adb shell 命令"></a>adb shell 命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">adb devices# 列出以连接的设备</span><br><span class="line">adb shell # 连接终端</span><br><span class="line">adb root # 进入root</span><br><span class="line">adb remount# 挂载手机</span><br><span class="line">adb install /test.apk# 安装test应用</span><br><span class="line">adb uninstall [packageName]  eg:adb uninstall com.miui.calculator </span><br><span class="line"><span class="meta">#</span> 卸载应用程序</span><br><span class="line">adb reboot bootloader# 进入fastboot模式</span><br><span class="line">adb reboot recovery# 进入recovery模式</span><br><span class="line">adb shell getprop# 获取Android的系统属性</span><br><span class="line">adb push c:/test.apk /mnt/sdcard# 将电脑C盘的test.apk push到手机端</span><br><span class="line">adb pull /mnt/sdcard/test.apk c:/# 将手机端的test.apk pull到电脑端</span><br><span class="line">adb ahell pm liat package -f # 获取手机内所有APK对应的路径和包名</span><br><span class="line">adb logcat &gt; D:/log.txt# 将获取的log日志放入D:/log.txt</span><br><span class="line">adb shell ps# 查看进程</span><br><span class="line">adb shell top -m 5# CPU占用前5名</span><br><span class="line">adb shell /system/app# 查看所有的APP文件</span><br><span class="line">adb shell dumpsys activity # 查询AMS服务相关信息</span><br><span class="line">adb shell dumpsys window # 查询WMS服务相关信息</span><br><span class="line">adb shell dumpsys cpuinfo # 查询CPU情况</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span> adb手机操作</span><br><span class="line">adb shell input keyevent 3# 模拟点击home键</span><br><span class="line">adb shell input keyevent 4# 模拟点击back键</span><br><span class="line">adb shell input text “001”# 输入001</span><br><span class="line">adb shell input tap 250 250# 点击坐标为（250，250）的位置</span><br><span class="line">adb shell input swipe 250 250 300 300# 滑动屏幕由（250，250）到（300，300）</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">adb shell dumpsys meminfo [packageName]# 查询内存情况</span><br><span class="line">adb logcat -b erents |findstr am_activity_launch_time# 查看APP启动时间</span><br><span class="line">adb shell cat /sys/class/leds/lcd-backlight/brighthess# 查看当前手机屏幕亮度</span><br><span class="line">adb shell screencap -p /sdcard/screen.png# 截图保存</span><br><span class="line">adb shell screenrecord --time-limit 10 /sdcard/demo.mp4 # 录制10秒的视频</span><br><span class="line">adb shell am start -n [packageName]/[packageName].[activityName]# 启动APP</span><br><span class="line">adb shell am start -n com.miui.calculator/.cal.CalculatorActivity </span><br><span class="line"><span class="meta">#</span> 命令行启动APP应用程序计算器</span><br><span class="line">aapt dump badging # 绝对路径/XX.apk 查询apk的包名和类名</span><br><span class="line">adb shell am start -n com.miui.calculator/</span><br><span class="line">com.miui.calculator.cal.CalculatorActivity</span><br><span class="line"><span class="meta">#</span> 打开一笔记账应用程序：</span><br><span class="line">adb shell am start -n com.mobivans.onestrokecharge/com.stub.stub01.Stub01 </span><br><span class="line">adb kill-server   # 停止adb服务器</span><br><span class="line">adb start-server  # 启动adb服务器</span><br><span class="line">adb shell pm list packages # 查询系统的应用程序包名；</span><br><span class="line">adb shell pm list packages -s # 指定查询系统自带的包名；</span><br><span class="line">adb shell pm list packages -3 # 查询第三方程序的包名  </span><br><span class="line">adb shell ps | findstr adbd # 查询运行在 Android 设备上的 adb 后台进程</span><br><span class="line">adb bugreport &gt; d:\bugreport.log # 打印缺陷日志报告至指定文件</span><br><span class="line">adb shell screencap -p /data/local/tmp/test001.png # 屏幕截图至指定路径</span><br><span class="line">adb shell getprop ro.serialno # 获取设备序列号</span><br><span class="line">adb get-serialno # 获取设备ID号</span><br><span class="line">adb shell monkey -p com.miui.calculator -s 999 --throttle 500 -v-v-v 300 </span><br><span class="line"><span class="meta">#</span> 每隔500毫秒执行一个事件，按随机种子ID为999，执行300次,显示详细信息</span><br><span class="line">adb shell monkey --pkg-whitelist-file /data/local/tmp/file.txt 1000</span><br><span class="line"><span class="meta">#</span> (需要提前将文件准备好)；准备白名单/黑名单的清单文件--上传至手机指定路径下--执行命令</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试基础</title>
      <link href="/2018/05/26/%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/05/26/%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><ul><li><strong>单元测试</strong>-UT-Unit Testing  （unittest单元测试框架、Junit-Java自带的单元测试框架 参照的需求文档文档：<strong>详细设计说明书</strong>）</li><li><strong>集成测试</strong>-IT-Intergration Testing （参照的需求文档：概要设计说明书（HLD））</li><li><strong>系统测试</strong>-ST-System Testing（参照的需求文档：需求规格说明书（SRS）/产品需求文档（PRD））</li><li><strong>验收测试</strong>-UAT-User Accept Test（参照的需求文档：需求规格说明书（SRS）；验收计划-项目型软件-用户参与）</li><li><strong>α测试</strong>-内测–开发在现场-可以掌控-部分用户参与-产品型软件</li><li><strong>β测试</strong>-公测–开发不在场–不可以掌控–生产环境、所有用户–产品型软件</li></ul><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><ul><li><p><strong>分析</strong> -  制定测试计划 – 资源（人力、软硬件）测试对象、测试范围、测试里程碑、组织架构、出口准则、测试挂起恢复准则等</p></li><li><p><strong>设计</strong> - 制定测试方案 – 测试对象、测试环境、测试策略、风险评估与应急措施、制定功能的重要级别、缺陷的重要级别等</p></li><li><p><strong>实现</strong> - 提取测试要点、编写测试用例、编写测试脚本 – 测试需求分析、测试用例、测试代码</p></li><li><p><strong>执行</strong>- 执行测试用例、运行测试脚本、提交缺陷、跟踪缺陷、提交测试报告</p></li></ul><h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><ul><li><p><strong>大爆炸模型</strong> - 无需求文档、无测试      </p></li><li><p><strong>瀑布模型</strong> - 串行执行、一句软件生命周期 </p></li><li><p><strong>迭代模型</strong> - 产品已在线上运行维护、周期短、项目小</p></li><li><p><strong>边写边改模型</strong> - 有非正规的需求文档   </p></li><li><p><strong>螺旋模型</strong> - 依据软件生命周期、加入制定目标、备份方案、风险分析及相应的解决方案</p></li><li><p><strong>敏捷开发模型</strong> -  敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态</p></li></ul><h2 id="测试过程模型"><a href="#测试过程模型" class="headerlink" title="测试过程模型"></a>测试过程模型</h2><ul><li><p><strong>V模型</strong> - 依据软件生命周期串行执行</p></li><li><p><strong>W模型/双V模型</strong> - 验证+确认，需求阶段介入测试</p></li><li><p><strong>H模型</strong> - 测试准备（测试需求分析、测试计划、测试方案、测试用例、测试脚本）+测试执行（运行脚本、执行用例、提交缺陷、跟踪缺陷、提交报告）</p></li><li><p><strong>X模型</strong> - 开发频繁交接代码模块，测试迭代测试，探索性测试</p></li></ul><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ul><li><p><strong>黑盒测试(系统测试阶段)</strong> - 不管程序的内部结构，只关注功能的测试方法</p></li><li><p><strong>黑盒测试方法</strong> -  等价类划分法、边界值法、判定表法、流程分析法/场景法、 正交实验、状态迁移法、因果图法、错误推测法</p></li><li><p><strong>灰盒测试(接口测试)</strong> - 既关注功能有关注程序内部结构 （集成测试阶段 - 灰盒测试 - 接口测试）</p></li><li><p><strong>接口测试类型</strong> </p><ul><li><p>基于代码的接口测试</p></li><li><p>基于协议的接口测试</p></li></ul></li><li><p><strong>白盒测试(单元测试阶段)</strong> - 只关注程序内部结构，不管功能是否满足需求，只关注代码设计</p></li><li><p><strong>白盒测试方法</strong> </p><ul><li><p>语句覆盖：覆盖每条语句，覆盖最弱</p></li><li><p>逻辑覆盖：与或非，覆盖逻辑</p></li><li><p>路径覆盖：覆盖每条路径，覆盖能力最强</p></li></ul></li></ul><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>ISO9000：实体企业进行质量管理体系、CMMI：能力成熟度密性继承（软件的质量管理体系）、六西格玛</p><h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><ul><li><p><strong>功能性</strong> - 适合性、准确性、互操作性、保密安全性、功能性的依从性</p></li><li><p><strong>可靠性</strong> - 成熟性、容错性、易恢复性、可靠性的依从性</p></li><li><p><strong>易用性</strong> - 易理解性、吸引性、易学性、易操控性、易用性的依从性</p></li><li><p><strong>效率</strong> -  响应时间、事务处理能力、吞吐量、资源利用率</p></li><li><p><strong>可维护性</strong> - 易分析性、易改变性、已测试性、稳定性、可维护性的依从性</p></li><li><p><strong>可移植性</strong> - 适应性、已安装性、共存性、易替换性、可移植性的依从性</p></li></ul><h2 id="六大测试类型"><a href="#六大测试类型" class="headerlink" title="六大测试类型"></a>六大测试类型</h2><ul><li><p><strong>功能性测试</strong> - 功能是否实现</p></li><li><p><strong>兼容性测试</strong> - 检查软件在不同的硬件平台、软件平台上是否可以正常的运行，即是通常说的软件的可移植性。</p></li><li><p><strong>可用性测试</strong> - 美观、满足用户的使用习惯、吸引性、易学性、易操作性</p></li><li><p><strong>可靠性测试</strong> - 容错能力、恢复性</p></li><li><p><strong>安全性测试</strong> - 钱+生命、密码机制、权限测试</p></li><li><p><strong>性能测试</strong> - 响应时间、吞吐量、事务处理能力、资源利用率、每秒点击数、RPS（每秒处理的请求数）</p></li></ul><h2 id="WEB漏洞扫描工具"><a href="#WEB漏洞扫描工具" class="headerlink" title="WEB漏洞扫描工具"></a>WEB漏洞扫描工具</h2><p>X-scan</p><h2 id="WEB安全测试"><a href="#WEB安全测试" class="headerlink" title="WEB安全测试"></a>WEB安全测试</h2><p>攻击主要类型</p><ul><li>认证与授权</li><li>Session与Cookie</li><li>暴力破解</li><li>跨站请求伪造（CSFR）</li><li>文件上传漏洞</li><li>SQL、XML注入</li><li>跨站脚本攻击（XSS）</li><li>分布式拒绝服务攻击（DOS）</li><li>信息泄露</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/2017/09/08/python%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/09/08/python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="index"><a href="#index" class="headerlink" title="index()"></a>index()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = [<span class="string">'hello'</span>, <span class="string">'hi'</span>, <span class="string">'howdy'</span>, <span class="string">'heyas'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.index(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="列表中添加值"><a href="#列表中添加值" class="headerlink" title="列表中添加值"></a>列表中添加值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># append()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.append(<span class="string">'moose'</span>)</span><br><span class="line">[<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>, <span class="string">'moose'</span>]</span><br><span class="line"><span class="comment"># insert()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.insert(<span class="number">1</span>,<span class="string">'chicken'</span>)</span><br><span class="line">[<span class="string">'cat'</span>, <span class="string">'chicken'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br></pre></td></tr></table></figure><h3 id="列表中删除值"><a href="#列表中删除值" class="headerlink" title="列表中删除值"></a>列表中删除值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.remove(<span class="string">'bat'</span>)</span><br><span class="line">[<span class="string">'cat'</span>, <span class="string">'dog'</span>]</span><br></pre></td></tr></table></figure><h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sort()可以按数字顺序，字母顺序排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.sort()</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br><span class="line"><span class="comment"># 制定reverse关键字参数为True，让sort()排倒序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="列表复制"><a href="#列表复制" class="headerlink" title="列表复制"></a>列表复制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy()浅度复制，deepcopy()深度复制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cheese = copy.copy(spam)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cheese[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cheese</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>] OR L[:<span class="number">3</span>] <span class="comment"># 取L列表的前三个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 从索引1开始取出两个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-1</span>] <span class="comment"># 取倒数第一个元素</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(rang(<span class="number">100</span>))<span class="comment"># 创建一个0-99的数列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>] <span class="comment"># 取出前十个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-10</span>:] <span class="comment"># 取出后十个数</span></span><br></pre></td></tr></table></figure><h3 id="字符列表互换"><a href="#字符列表互换" class="headerlink" title="字符列表互换"></a>字符列表互换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lstr = list(map(str, ls))<span class="comment"># 整数列表转化为字符串列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">','</span>.join(ls)<span class="comment"># 列表转换字符串</span></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'1,2,3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = str.strip().split(<span class="string">','</span>)<span class="comment"># 以逗号为分隔转为列表</span></span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = &#123;<span class="string">'color'</span>:<span class="string">'red'</span>, <span class="string">'age'</span>:<span class="string">'12'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.keys()</span><br><span class="line">dict_keys([<span class="string">'color'</span>, <span class="string">'age'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(spam.keys())</span><br><span class="line">[<span class="string">'color'</span>, <span class="string">'age'</span>]</span><br></pre></td></tr></table></figure><h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = &#123;<span class="string">'color'</span>:<span class="string">'red'</span>, <span class="string">'age'</span>:<span class="string">'12'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> spam.values():</span><br><span class="line">    print(i)</span><br><span class="line">red</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="items"><a href="#items" class="headerlink" title="items()"></a>items()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = &#123;<span class="string">'color'</span>:<span class="string">'red'</span>, <span class="string">'age'</span>:<span class="string">'12'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, j <span class="keyword">in</span> spam.items():</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(<span class="string">'Key: '</span> + i + <span class="string">'Value: '</span> + str(j))</span><br><span class="line">Key: age Value: <span class="number">12</span></span><br><span class="line">Key: color Value: red</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>在访问一个键的值之前，检查该键是否存在字典中，这很麻烦。好在字典有一个get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>picnicItems = &#123;<span class="string">'apples'</span>: <span class="number">5</span>, <span class="string">'cups'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>picnicItems.get(<span class="string">'cups'</span>, <span class="number">0</span> )</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>picnicItems.get(<span class="string">'eggs'</span>, <span class="number">0</span> )</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault()"></a>setdefault()</h3><p>方法提供了一种方式，在一行中完成这件事。传递给该方法的第一个参数，是要检查的键。第二个参数，如果改建不存在时要设置的值。如果该键确实存在，方法就会返回键的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = &#123;<span class="string">'name'</span>: <span class="string">'pooka'</span>, <span class="string">'age'</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.setdefault(<span class="string">'color'</span>, <span class="string">'black'</span>)</span><br><span class="line"><span class="string">'black'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.setdefault(<span class="string">'color'</span>, <span class="string">'while'</span>)</span><br><span class="line"><span class="string">'black'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'black'</span>, <span class="string">'name'</span>: <span class="string">'pooka'</span>, <span class="string">'age'</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="upper-lower"><a href="#upper-lower" class="headerlink" title="upper()/lower()"></a>upper()/lower()</h3><p>upper()和lower()字符串方法返回一个新字符，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非非字母字符保持不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = spam.upper()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam</span><br><span class="line"><span class="string">'HELLO WORLD!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = spam.lower()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam</span><br><span class="line"><span class="string">'hello world!'</span></span><br></pre></td></tr></table></figure><h3 id="isupper-islower"><a href="#isupper-islower" class="headerlink" title="isupper()/islower()"></a>isupper()/islower()</h3><p>如果字符串至少有一个字母，并且所有字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值True.否则返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.isupper()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.islower()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>反参</th><th>解释</th></tr></thead><tbody><tr><td>isalpha()</td><td>True</td><td>如果字符串只包含字母，并且非空</td></tr><tr><td>isalnum()</td><td>True</td><td>如果字符串只包含字母和数字，并且非空</td></tr><tr><td>isdecimal()</td><td>True</td><td>如果字符串只包含数字字符，并且非空</td></tr><tr><td>isspace()</td><td>True</td><td>如果字符串只包含空格、制表符和换行符，并且非空</td></tr><tr><td>istitle()</td><td>True</td><td>如果字符串仅包含以大写字母开头、后面都是小写字母的单词</td></tr></tbody></table><h3 id="startswith-endswith"><a href="#startswith-endswith" class="headerlink" title="startswith()/endswith()"></a>startswith()/endswith()</h3><p>startswith()和endswith()方法返回True,如果它们所调用的字符串以该方式传入的字符串开始或结束。否则，方法返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello world!'</span>.startswith(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello world!'</span>.endswith(<span class="string">'world!'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="join-split"><a href="#join-split" class="headerlink" title="join()/split()"></a>join()/split()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">','</span>.join([<span class="string">'cats'</span>, <span class="string">'rats'</span>, <span class="string">'bats'</span>])</span><br><span class="line"><span class="string">'cats, rats, bats'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' '</span>.join([<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'a'</span>, <span class="string">'cat'</span>])</span><br><span class="line"><span class="string">'I am a cat'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.join([<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'a'</span>, <span class="string">'cat'</span>])</span><br><span class="line"><span class="string">'IABCamABCaABCcat'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'I am a cat'</span>.split()</span><br><span class="line">[<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'a'</span>, <span class="string">'cat'</span>]</span><br></pre></td></tr></table></figure><h3 id="rjust-ljust-center"><a href="#rjust-ljust-center" class="headerlink" title="rjust()/ljust()/center()"></a>rjust()/ljust()/center()</h3><p>对齐文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.rjust(<span class="number">10</span>)</span><br><span class="line"><span class="string">'          Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'                    Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.ljust(<span class="number">10</span>)</span><br><span class="line"><span class="string">'Hello          '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.rjust(<span class="number">10</span>, <span class="string">'*'</span>)</span><br><span class="line"><span class="string">'**********Hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.ljust(<span class="number">10</span>, <span class="string">'*'</span>)</span><br><span class="line"><span class="string">'Hello**********'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.center(<span class="number">10</span>)</span><br><span class="line"><span class="string">'          Hello          '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello'</span>.center(<span class="number">10</span>, <span class="string">'='</span>)</span><br><span class="line"><span class="string">'==========Hello=========='</span></span><br></pre></td></tr></table></figure><h3 id="strip-rstrip-lstrip"><a href="#strip-rstrip-lstrip" class="headerlink" title="strip()/rstrip()/lstrip()"></a>strip()/rstrip()/lstrip()</h3><p>strip()字符串方法将返回一个首位没有空白符的字符，lstrip()和rstrip()方法将删除左边或右边的空白字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="string">' Hello world! '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.strip()</span><br><span class="line"><span class="string">'Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.lstrip()</span><br><span class="line"><span class="string">'Hello world! '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam.rstrip()</span><br><span class="line"><span class="string">' Hello world!'</span></span><br></pre></td></tr></table></figure><h3 id="pyperclip"><a href="#pyperclip" class="headerlink" title="pyperclip"></a>pyperclip</h3><p>用pyperclip模块拷贝粘贴字符串</p><h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><p><strong>使用heapq模块的nlargest()和nsmallest()来查找最大或最小的N个元素</strong></p><table><thead><tr><th align="left">方法名</th><th align="left">简介</th></tr></thead><tbody><tr><td align="left">nsmallest(n,iterable,key=None)</td><td align="left">获取列表里面最小的几个值</td></tr><tr><td align="left">nlargest(n,iterable,key=None)</td><td align="left">获取列表里面最大的几个值</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Import heapq</span><br><span class="line">nums=[<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-78</span>,<span class="number">23</span>,<span class="number">9</span>,<span class="number">45</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>,nums)) <span class="comment"># 获取列表里面最大的几个值</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>,nums))  <span class="comment"># 获取列表里面最小的几个值</span></span><br><span class="line">portfolio=[</span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'IBM'</span>,<span class="string">'shares'</span>:<span class="number">100</span>,<span class="string">'price'</span>:<span class="number">91.1</span>&#125;,</span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'AAPL'</span>,<span class="string">'shares'</span>:<span class="number">50</span>,<span class="string">'price'</span>:<span class="number">543.22</span>&#125;,</span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'FB'</span>,<span class="string">'shares'</span>:<span class="number">200</span>,<span class="string">'price'</span>:<span class="number">21.09</span>&#125;,</span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'HPQ'</span>,<span class="string">'shares'</span>:<span class="number">35</span>,<span class="string">'price'</span>:<span class="number">31.75</span>&#125;,</span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'YHOO'</span>,<span class="string">'shares'</span>:<span class="number">45</span>,<span class="string">'price'</span>:<span class="number">16.35</span>&#125;,</span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'ACME'</span>,<span class="string">'shares'</span>:<span class="number">75</span>,<span class="string">'price'</span>:<span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">Cheap = heapq.nsmallest(<span class="number">3</span>,portfolio,key=lambdas:s[<span class="string">'shares'</span>])</span><br><span class="line">Expensive = heapq.nlargest(<span class="number">3</span>,portfolio,key=lambdas:s[<span class="string">'price'</span>])</span><br><span class="line">print(cheap)</span><br></pre></td></tr></table></figure><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p>解析HTML</p><p> <strong>select()方法寻找元素：</strong></p><table><thead><tr><th><strong>传递给</strong> select()方法的选择器</th><th>将匹配…</th></tr></thead><tbody><tr><td>soup.select(‘div’)</td><td>所有名为&lt;div&gt;的元素</td></tr><tr><td>soup.select(‘#author’)</td><td>带有 id 属性为 author 的元素</td></tr><tr><td>soup.select(‘.notice’)</td><td>所有使用 CSS class 属性名为 notice 的元素</td></tr><tr><td>soup.select(‘div span’)</td><td>所有在&lt;div&gt;元素之内的&lt;span&gt;元素</td></tr><tr><td>soup.select(‘div &gt; span’)</td><td>所有直接在&lt;div&gt;元素之内的&lt;span&gt;元素，中间没有其他元素</td></tr><tr><td>soup.select(‘input[name]’)</td><td>所有名为&lt;input&gt;，并有一个 name 属性，其值无所谓的元素</td></tr><tr><td>soup.select(‘input[type=”button”]’)</td><td>所有名为&lt;input&gt;，并有一个 type 属性，其值为 button 的元素</td></tr></tbody></table><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><ul><li><strong>loads()</strong> - 将json数据转化成dict数据</li><li><strong>dumps()</strong> - 将dict数据转化成json数据</li><li><strong>load()</strong> - 读取json文件数据，转成dict数据</li><li><strong>dump()</strong> - 将dict数据转化成json数据后写入json文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dict字典转json数据</span></span><br><span class="line">dt = &#123;<span class="string">'name'</span>:<span class="string">'tom'</span>,<span class="string">'age'</span>:<span class="string">'11'</span>&#125;</span><br><span class="line">js = json.dumps(dt)</span><br><span class="line"><span class="comment"># json数据转dict字典</span></span><br><span class="line">d = json.loads(js)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
